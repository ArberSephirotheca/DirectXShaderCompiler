=== COMMAND ===
/home/t-zheychen/dxc_workspace/DirectXShaderCompiler/build-fuzzer/bin/minihlsl-standalone -o 1 /home/t-zheychen/dxc_workspace/DirectXShaderCompiler/tools/clang/tools/dxc-fuzzer/examples/control_flow_while_continue.hlsl

=== RETURN CODE ===
0

=== STDOUT ===
MiniHLSL Interpreter
====================
Input file: /home/t-zheychen/dxc_workspace/DirectXShaderCompiler/tools/clang/tools/dxc-fuzzer/examples/control_flow_while_continue.hlsl
Wave size: 32
Order verification: 1 orderings

Converting HLSL function: main
Found numthreads attribute: [4, 1, 1]
Converting compound statement with 5 child statements
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: laneId
Converting expression: CallExpr
Converting function call to expression: WaveGetLaneIndex
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: result
Converting expression: ImplicitCastExpr
Converting expression: IntegerLiteral
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: i
Converting expression: ImplicitCastExpr
Converting expression: IntegerLiteral
Converting statement: WhileStmt
Converting while statement
Converting expression: BinaryOperator
Converting expression: ImplicitCastExpr
Converting expression: DeclRefExpr
Converting expression: ImplicitCastExpr
Converting expression: IntegerLiteral
Converting statement: IfStmt
Converting if statement
Converting expression: BinaryOperator
Converting expression: BinaryOperator
Converting expression: ImplicitCastExpr
Converting expression: DeclRefExpr
Converting expression: ImplicitCastExpr
Converting expression: ImplicitCastExpr
Converting expression: DeclRefExpr
Converting expression: BinaryOperator
Converting expression: ImplicitCastExpr
Converting expression: DeclRefExpr
Converting expression: ImplicitCastExpr
Converting expression: IntegerLiteral
Converting statement: CompoundAssignOperator
Converting compound assignment operator
Converting expression: DeclRefExpr
Converting expression: ImplicitCastExpr
Converting expression: IntegerLiteral
Converting statement: ContinueStmt
Converting continue statement
Converting statement: CompoundAssignOperator
Converting compound assignment operator
Converting expression: DeclRefExpr
Converting expression: ImplicitCastExpr
Converting expression: CallExpr
Converting function call to expression: WaveActiveSum
Converting expression: IntegerLiteral
Converting statement: CompoundAssignOperator
Converting compound assignment operator
Converting expression: DeclRefExpr
Converting expression: ImplicitCastExpr
Converting expression: IntegerLiteral
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: totalSum
Converting expression: CallExpr
Converting function call to expression: WaveActiveSum
Converting expression: ImplicitCastExpr
Converting expression: DeclRefExpr
Converted AST to interpreter program with 5 statements
Thread configuration: [4, 1, 1]

DEBUG: findOrCreateBlockForPath called with 0 waves of unknown lanes
DEBUG: Initializing wave 0 with 4 lanes in initial block 1
DEBUG: markLaneArrived - Lane 0 transitioned from Unknown to Participating in block 1
DEBUG: Lane 0 assigned to block 1
DEBUG: markLaneArrived - Lane 1 transitioned from Unknown to Participating in block 1
DEBUG: Lane 1 assigned to block 1
DEBUG: markLaneArrived - Lane 2 transitioned from Unknown to Participating in block 1
DEBUG: Lane 2 assigned to block 1
DEBUG: markLaneArrived - Lane 3 transitioned from Unknown to Participating in block 1
DEBUG: Lane 3 assigned to block 1
DEBUG: WhileStmt - Lane 0 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 2
DEBUG: addUnknownLane - adding lane 1 to new block 2
DEBUG: addUnknownLane - adding lane 2 to new block 2
DEBUG: addUnknownLane - adding lane 3 to new block 2
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 3
DEBUG: addUnknownLane - adding lane 1 to new block 3
DEBUG: addUnknownLane - adding lane 2 to new block 3
DEBUG: addUnknownLane - adding lane 3 to new block 3
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 0 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 1 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - moving lane 1 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 1 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 2 participating lanes (0 1), 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - END: lane 1 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 2 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 2
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 2 participating lanes (0 1), 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 3 participating lanes (0 1 2), 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 2
DEBUG: WhileStmt - Lane 2 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 3 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 2
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 3 participating lanes (0 1 2), 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - moving lane 3 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 2
DEBUG: WhileStmt - Lane 3 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 starting Result-based if statement
DEBUG: IfStmt - Lane 0 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 0 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 0
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 0
DEBUG: IfStmt - Lane 0 condition result=1 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 4
DEBUG: addUnknownLane - adding lane 1 to new block 4
DEBUG: addUnknownLane - adding lane 2 to new block 4
DEBUG: addUnknownLane - adding lane 3 to new block 4
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 5
DEBUG: addUnknownLane - adding lane 1 to new block 5
DEBUG: addUnknownLane - adding lane 2 to new block 5
DEBUG: addUnknownLane - adding lane 3 to new block 5
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 0 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 0 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 starting Result-based if statement
DEBUG: IfStmt - Lane 1 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 1 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 1
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 1
DEBUG: IfStmt - Lane 1 condition result=1 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 1 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 1 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 2 resuming Result-based while loop
DEBUG: WhileStmt - Lane 2 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 2 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 2 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 2 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 2 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 2 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 2 starting Result-based if statement
DEBUG: IfStmt - Lane 2 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 2 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 2
DEBUG: VariableExpr - Lane 2 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 2
DEBUG: IfStmt - Lane 2 condition result=0 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 2 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 2 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 3 resuming Result-based while loop
DEBUG: WhileStmt - Lane 3 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 3 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 3 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 3 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 3 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 3 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 3 starting Result-based if statement
DEBUG: IfStmt - Lane 3 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 3 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 3
DEBUG: VariableExpr - Lane 3 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 3
DEBUG: IfStmt - Lane 3 condition result=0 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 3 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 3 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 0 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 1 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: WhileStmt - Lane 2 resuming Result-based while loop
DEBUG: WhileStmt - Lane 2 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 2 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 2 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 2 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 2 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 2 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 2 resuming Result-based if statement
DEBUG: IfStmt - Lane 2 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 in phase Reconverging (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 performing reconvergence from block 2 to laneSpecificMergeBlockId=5
DEBUG: IfStmt - Lane 2 merge stack before reconvergence (size=3):
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
DEBUG: IfStmt - Lane 2 popping stack at reconvergence (depth 2->1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 popping merge point before assigning to block 5
DEBUG: IfStmt - Lane 2 assigning to merge block 5
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 5
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 5
DEBUG: assignLaneToBlock - BEFORE: block 5 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 2 (type 4) to block 5 (type 3), isHeaderToLoopBody=1
DEBUG: Keeping lane 2 as Participating in header block 2 while also adding to loop body block 5
DEBUG: assignLaneToBlock - AFTER: block 5 has 1 participating lanes (2), 0 waiting lanes, 3 unknown lanes (0 1 3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 5
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 5
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 4
DEBUG: removeThreadFromAllSets - block 4 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 4 has 0 participating lanes after removal
DEBUG: IfStmt - Lane 2 reconvergence complete
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 2 natural flow from block 2 to block 5 during statement 0 (likely merge block, Result-based)
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 2 executing statement 1 in block 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 5, instruction key=(0x503000001a50,5)
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 5
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 5
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 5
DEBUG: WAVE_OP: Resolution status tracked by registry for block 5
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: Block 5 wave 0 unknown lanes: {0 1 3 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 3 unknown lanes: 0 1 3  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 3 unknown lanes: 0 1 3  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 2 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 3 unknown lanes: 0 1 3  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 3 resuming Result-based while loop
DEBUG: WhileStmt - Lane 3 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 3 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 3 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 3 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 3 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 3 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 3 resuming Result-based if statement
DEBUG: IfStmt - Lane 3 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 in phase Reconverging (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 performing reconvergence from block 2 to laneSpecificMergeBlockId=5
DEBUG: IfStmt - Lane 3 merge stack before reconvergence (size=3):
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
DEBUG: IfStmt - Lane 3 popping stack at reconvergence (depth 2->1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 popping merge point before assigning to block 5
DEBUG: IfStmt - Lane 3 assigning to merge block 5
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 5
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 5
DEBUG: assignLaneToBlock - BEFORE: block 5 has 0 participating lanes, 1 waiting lanes (2), 3 unknown lanes (0 1 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 2 (type 4) to block 5 (type 3), isHeaderToLoopBody=1
DEBUG: Keeping lane 3 as Participating in header block 2 while also adding to loop body block 5
DEBUG: assignLaneToBlock - AFTER: block 5 has 1 participating lanes (3), 1 waiting lanes (2), 2 unknown lanes (0 1)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 5
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 5
DEBUG: removeThreadFromAllSets - removing lane 3 from all sets of block 4
DEBUG: removeThreadFromAllSets - block 4 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 4 has 0 participating lanes after removal
DEBUG: IfStmt - Lane 3 reconvergence complete
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 3 natural flow from block 2 to block 5 during statement 0 (likely merge block, Result-based)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 3 executing statement 1 in block 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 5, instruction key=(0x503000001a50,5)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 5
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 5
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 5
DEBUG: WAVE_OP: Resolution status tracked by registry for block 5
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: Block 5 wave 0 unknown lanes: {0 1 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 1 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 1 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 1 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000196d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000196d0 for iteration 1
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 1 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000196d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000196d0 for iteration 1
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 2 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 2 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 2 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000296d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000296d0 for iteration 2
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 2 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000296d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000296d0 for iteration 2
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 3 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 3 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 3 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000396d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000396d0 for iteration 3
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 3 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000396d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000396d0 for iteration 3
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 4 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 4 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 4 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000496d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000496d0 for iteration 4
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 4 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000496d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000496d0 for iteration 4
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 5 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000596d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000596d0 for iteration 5
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 5 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000596d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000596d0 for iteration 5
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 6 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 6 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 6 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000696d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000696d0 for iteration 6
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 6 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000696d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000696d0 for iteration 6
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 7 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 7 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 7 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000796d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000796d0 for iteration 7
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 7 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000796d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000796d0 for iteration 7
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 8 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 8 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 8 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000896d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000896d0 for iteration 8
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 8 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000896d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000896d0 for iteration 8
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 9 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 9 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 9 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000996d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000996d0 for iteration 9
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 9 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000996d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000996d0 for iteration 9
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 10 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 10 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 10 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000a96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000a96d0 for iteration 10
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 10 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000a96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000a96d0 for iteration 10
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 11 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 11 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 11 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000b96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000b96d0 for iteration 11
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 11 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000b96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000b96d0 for iteration 11
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 12 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 12 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 12 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000c96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000c96d0 for iteration 12
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 12 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000c96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000c96d0 for iteration 12
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 13 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 13 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 13 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000d96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000d96d0 for iteration 13
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 13 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000d96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000d96d0 for iteration 13
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 14 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 14 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 14 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000e96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000e96d0 for iteration 14
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 14 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000e96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000e96d0 for iteration 14
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 15 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 15 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 15 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000f96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000f96d0 for iteration 15
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 15 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000f96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000f96d0 for iteration 15
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 16 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 16 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 16 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001096d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001096d0 for iteration 16
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 16 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001096d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001096d0 for iteration 16
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 17 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 17 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 17 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001196d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001196d0 for iteration 17
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 17 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001196d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001196d0 for iteration 17
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 18 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 18 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 18 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001296d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001296d0 for iteration 18
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 18 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001296d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001296d0 for iteration 18
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 19 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 19 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 19 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001396d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001396d0 for iteration 19
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 19 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001396d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001396d0 for iteration 19
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 20 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 20 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 20 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001496d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001496d0 for iteration 20
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 20 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001496d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001496d0 for iteration 20
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 21 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 21 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 21 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001596d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001596d0 for iteration 21
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 21 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001596d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001596d0 for iteration 21
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 22 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 22 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 22 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001696d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001696d0 for iteration 22
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 22 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001696d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001696d0 for iteration 22
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 23 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 23 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 23 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001796d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001796d0 for iteration 23
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 23 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001796d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001796d0 for iteration 23
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 24 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 24 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 24 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001896d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001896d0 for iteration 24
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 24 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001896d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001896d0 for iteration 24
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 25 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 25 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 25 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001996d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001996d0 for iteration 25
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 25 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001996d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001996d0 for iteration 25
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 26 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 26 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 26 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001a96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001a96d0 for iteration 26
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 26 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001a96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001a96d0 for iteration 26
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 27 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 27 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 27 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001b96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001b96d0 for iteration 27
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 27 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001b96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001b96d0 for iteration 27
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 28 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 28 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 28 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001c96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001c96d0 for iteration 28
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 28 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001c96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001c96d0 for iteration 28
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 29 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 29 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 29 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001d96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001d96d0 for iteration 29
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 29 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001d96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001d96d0 for iteration 29
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 30 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 30 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 30 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001e96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001e96d0 for iteration 30
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 30 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001e96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001e96d0 for iteration 30
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 31 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 31 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 31 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001f96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001f96d0 for iteration 31
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 31 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001f96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001f96d0 for iteration 31
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 32 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 32 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 32 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002096d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002096d0 for iteration 32
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 32 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002096d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002096d0 for iteration 32
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 33 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 33 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 33 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002196d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002196d0 for iteration 33
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 33 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002196d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002196d0 for iteration 33
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 34 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 34 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 34 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002296d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002296d0 for iteration 34
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 34 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002296d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002296d0 for iteration 34
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 35 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 35 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 35 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002396d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002396d0 for iteration 35
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 35 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002396d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002396d0 for iteration 35
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 36 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 36 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 36 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002496d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002496d0 for iteration 36
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 36 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002496d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002496d0 for iteration 36
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 37 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 37 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 37 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002596d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002596d0 for iteration 37
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 37 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002596d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002596d0 for iteration 37
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 38 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 38 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 38 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002696d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002696d0 for iteration 38
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 38 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002696d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002696d0 for iteration 38
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 39 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 39 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 39 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002796d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002796d0 for iteration 39
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 39 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002796d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002796d0 for iteration 39
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 40 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 40 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 40 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002896d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002896d0 for iteration 40
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 40 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002896d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002896d0 for iteration 40
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 41 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 41 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 41 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002996d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002996d0 for iteration 41
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 41 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002996d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002996d0 for iteration 41
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 42 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 42 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 42 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002a96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002a96d0 for iteration 42
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 42 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002a96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002a96d0 for iteration 42
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 43 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 43 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 43 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002b96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002b96d0 for iteration 43
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 43 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002b96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002b96d0 for iteration 43
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 44 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 44 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 44 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002c96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002c96d0 for iteration 44
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 44 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002c96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002c96d0 for iteration 44
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
=== Sequential Execution ===
 Execution failed: Execution timeout: possible infinite loop or deadlock
DEBUG: findOrCreateBlockForPath called with 0 waves of unknown lanes
DEBUG: Initializing wave 0 with 4 lanes in initial block 1
DEBUG: markLaneArrived - Lane 0 transitioned from Unknown to Participating in block 1
DEBUG: Lane 0 assigned to block 1
DEBUG: markLaneArrived - Lane 1 transitioned from Unknown to Participating in block 1
DEBUG: Lane 1 assigned to block 1
DEBUG: markLaneArrived - Lane 2 transitioned from Unknown to Participating in block 1
DEBUG: Lane 2 assigned to block 1
DEBUG: markLaneArrived - Lane 3 transitioned from Unknown to Participating in block 1
DEBUG: Lane 3 assigned to block 1
DEBUG: WhileStmt - Lane 0 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 2
DEBUG: addUnknownLane - adding lane 1 to new block 2
DEBUG: addUnknownLane - adding lane 2 to new block 2
DEBUG: addUnknownLane - adding lane 3 to new block 2
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 3
DEBUG: addUnknownLane - adding lane 1 to new block 3
DEBUG: addUnknownLane - adding lane 2 to new block 3
DEBUG: addUnknownLane - adding lane 3 to new block 3
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 0 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 1 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - moving lane 1 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 1 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 2 participating lanes (0 1), 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - END: lane 1 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 2 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 2
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 2 participating lanes (0 1), 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 3 participating lanes (0 1 2), 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 2
DEBUG: WhileStmt - Lane 2 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 3 starting Result-based while loop
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 2
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 3 participating lanes (0 1 2), 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - moving lane 3 from block 1 (type 0) to block 2 (type 4), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 2
DEBUG: WhileStmt - Lane 3 evaluating condition for iteration 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 starting Result-based if statement
DEBUG: IfStmt - Lane 0 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 0 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 0
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 0
DEBUG: IfStmt - Lane 0 condition result=1 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 4
DEBUG: addUnknownLane - adding lane 1 to new block 4
DEBUG: addUnknownLane - adding lane 2 to new block 4
DEBUG: addUnknownLane - adding lane 3 to new block 4
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 5
DEBUG: addUnknownLane - adding lane 1 to new block 5
DEBUG: addUnknownLane - adding lane 2 to new block 5
DEBUG: addUnknownLane - adding lane 3 to new block 5
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 0 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 0 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 starting Result-based if statement
DEBUG: IfStmt - Lane 1 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 1 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 1
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 1
DEBUG: IfStmt - Lane 1 condition result=1 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 1 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 1 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 2 resuming Result-based while loop
DEBUG: WhileStmt - Lane 2 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 2 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 2 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 2 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 2 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 2 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 2 starting Result-based if statement
DEBUG: IfStmt - Lane 2 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 2 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 2
DEBUG: VariableExpr - Lane 2 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 2
DEBUG: IfStmt - Lane 2 condition result=0 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 2 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 2 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 3 resuming Result-based while loop
DEBUG: WhileStmt - Lane 3 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 3 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 3 merge stack size: 1
  Stack[0]: sourceStatement=0x5040000046d0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 3 pushed iteration merge point 0x5040000096d0 for iteration 0
DEBUG: WhileStmt - Lane 3 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 3 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 3 starting Result-based if statement
DEBUG: IfStmt - Lane 3 starting fresh execution (pushed to stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 in phase EvaluatingCondition (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 evaluating condition (Result-based)
DEBUG: IfStmt - Lane 3 evaluating condition for first time (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 3
DEBUG: VariableExpr - Lane 3 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 3
DEBUG: IfStmt - Lane 3 condition result=0 (Result-based)
DEBUG: createIfBlocks - ifStmt=0x5060000016a0, parentBlockId=2, hasElse=0
DEBUG: createIfBlocks - mergeStack size=3
  MergeStack[0]: sourceStatement=0x5040000046d0
  MergeStack[1]: sourceStatement=0x5040000096d0
  MergeStack[2]: sourceStatement=0x5060000016a0
DEBUG: createIfBlocks - executionPath size=0
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: createIfBlocks - Created blocks: thenBlockId=4, elseBlockId=0, mergeBlockId=5
DEBUG: IfStmt - Lane 3 setup complete: thenBlockId=4, elseBlockId=0, mergeBlockId=5 (Result-based)
DEBUG: WhileStmt - Lane 3 child statement needs resume (Result-based)
  Block before: 2, Block after: 2
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 0 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 1 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 0 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 0
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: WhileStmt - Lane 2 resuming Result-based while loop
DEBUG: WhileStmt - Lane 2 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 2 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 2 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 2 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 2 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 2 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 2 resuming Result-based if statement
DEBUG: IfStmt - Lane 2 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 in phase Reconverging (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 performing reconvergence from block 2 to laneSpecificMergeBlockId=5
DEBUG: IfStmt - Lane 2 merge stack before reconvergence (size=3):
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
DEBUG: IfStmt - Lane 2 popping stack at reconvergence (depth 2->1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 2 popping merge point before assigning to block 5
DEBUG: IfStmt - Lane 2 assigning to merge block 5
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 5
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 5
DEBUG: assignLaneToBlock - BEFORE: block 5 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 2 (type 4) to block 5 (type 3), isHeaderToLoopBody=1
DEBUG: Keeping lane 2 as Participating in header block 2 while also adding to loop body block 5
DEBUG: assignLaneToBlock - AFTER: block 5 has 1 participating lanes (2), 0 waiting lanes, 3 unknown lanes (0 1 3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 5
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 5
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 4
DEBUG: removeThreadFromAllSets - block 4 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 4 has 0 participating lanes after removal
DEBUG: IfStmt - Lane 2 reconvergence complete
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 2 natural flow from block 2 to block 5 during statement 0 (likely merge block, Result-based)
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 2 executing statement 1 in block 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 2 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 5, instruction key=(0x503000001a50,5)
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 5
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 5
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 5
DEBUG: WAVE_OP: Resolution status tracked by registry for block 5
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: Block 5 wave 0 unknown lanes: {0 1 3 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 3 unknown lanes: 0 1 3  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 3 unknown lanes: 0 1 3  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 2 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 3 unknown lanes: 0 1 3  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 3 resuming Result-based while loop
DEBUG: WhileStmt - Lane 3 executing body for iteration 0 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 3 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 3 merge stack size: 3
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
  Looking for iterationMarker=0x5040000096d0
DEBUG: WhileStmt - Lane 3 iteration merge point already found in merge stack
DEBUG: WhileStmt - Lane 3 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 3 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 3 resuming Result-based if statement
DEBUG: IfStmt - Lane 3 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 in phase Reconverging (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 performing reconvergence from block 2 to laneSpecificMergeBlockId=5
DEBUG: IfStmt - Lane 3 merge stack before reconvergence (size=3):
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Stack[2]: sourceStatement=0x5060000016a0
DEBUG: IfStmt - Lane 3 popping stack at reconvergence (depth 2->1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 3 popping merge point before assigning to block 5
DEBUG: IfStmt - Lane 3 assigning to merge block 5
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 5
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 5
DEBUG: assignLaneToBlock - BEFORE: block 5 has 0 participating lanes, 1 waiting lanes (2), 3 unknown lanes (0 1 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 2 (type 4) to block 5 (type 3), isHeaderToLoopBody=1
DEBUG: Keeping lane 3 as Participating in header block 2 while also adding to loop body block 5
DEBUG: assignLaneToBlock - AFTER: block 5 has 1 participating lanes (3), 1 waiting lanes (2), 2 unknown lanes (0 1)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 5
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 5
DEBUG: removeThreadFromAllSets - removing lane 3 from all sets of block 4
DEBUG: removeThreadFromAllSets - block 4 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 4 has 0 participating lanes after removal
DEBUG: IfStmt - Lane 3 reconvergence complete
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 3 natural flow from block 2 to block 5 during statement 0 (likely merge block, Result-based)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WhileStmt - Lane 3 executing statement 1 in block 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 3 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 5, instruction key=(0x503000001a50,5)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 5
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 5
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 5
DEBUG: WAVE_OP: Resolution status tracked by registry for block 5
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: Block 5 wave 0 unknown lanes: {0 1 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 1 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 1 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 1 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000196d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000196d0 for iteration 1
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 1 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000196d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000196d0 for iteration 1
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 2 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 2 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 2 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000296d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000296d0 for iteration 2
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 2 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000296d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000296d0 for iteration 2
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 3 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 3 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 3 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000396d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000396d0 for iteration 3
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 3 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000396d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000396d0 for iteration 3
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 4 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 4 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 4 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000496d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000496d0 for iteration 4
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 4 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000496d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000496d0 for iteration 4
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 5 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 5 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000596d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000596d0 for iteration 5
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 5 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000596d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000596d0 for iteration 5
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 6 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 6 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 6 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000696d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000696d0 for iteration 6
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 6 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000696d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000696d0 for iteration 6
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 7 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 7 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 7 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000796d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000796d0 for iteration 7
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 7 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000796d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000796d0 for iteration 7
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 8 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 8 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 8 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000896d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000896d0 for iteration 8
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 8 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000896d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000896d0 for iteration 8
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 9 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 9 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 9 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000996d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000996d0 for iteration 9
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 9 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000996d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000996d0 for iteration 9
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 10 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 10 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 10 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000a96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000a96d0 for iteration 10
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 10 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000a96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000a96d0 for iteration 10
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 11 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 11 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 11 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000b96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000b96d0 for iteration 11
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 11 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000b96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000b96d0 for iteration 11
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 12 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 12 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 12 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000c96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000c96d0 for iteration 12
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 12 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000c96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000c96d0 for iteration 12
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 13 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 13 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 13 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000d96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000d96d0 for iteration 13
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 13 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000d96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000d96d0 for iteration 13
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 14 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 14 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 14 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000e96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000e96d0 for iteration 14
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 14 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000e96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000e96d0 for iteration 14
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 15 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 15 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 15 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000f96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040000f96d0 for iteration 15
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 15 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040000f96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040000f96d0 for iteration 15
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 16 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 16 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 16 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001096d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001096d0 for iteration 16
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 16 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001096d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001096d0 for iteration 16
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 17 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 17 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 17 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001196d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001196d0 for iteration 17
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 17 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001196d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001196d0 for iteration 17
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 18 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 18 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 18 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001296d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001296d0 for iteration 18
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 18 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001296d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001296d0 for iteration 18
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 19 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 19 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 19 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001396d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001396d0 for iteration 19
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 19 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001396d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001396d0 for iteration 19
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 20 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 20 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 20 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001496d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001496d0 for iteration 20
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 20 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001496d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001496d0 for iteration 20
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 21 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 21 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 21 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001596d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001596d0 for iteration 21
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 21 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001596d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001596d0 for iteration 21
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 22 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 22 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 22 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001696d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001696d0 for iteration 22
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 22 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001696d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001696d0 for iteration 22
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 23 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 23 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 23 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001796d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001796d0 for iteration 23
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 23 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001796d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001796d0 for iteration 23
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 24 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 24 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 24 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001896d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001896d0 for iteration 24
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 24 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001896d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001896d0 for iteration 24
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 25 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 25 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 25 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001996d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001996d0 for iteration 25
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 25 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001996d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001996d0 for iteration 25
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 26 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 26 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 26 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001a96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001a96d0 for iteration 26
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 26 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001a96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001a96d0 for iteration 26
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 27 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 27 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 27 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001b96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001b96d0 for iteration 27
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 27 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001b96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001b96d0 for iteration 27
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 28 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 28 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 28 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001c96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001c96d0 for iteration 28
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 28 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001c96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001c96d0 for iteration 28
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 29 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 29 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 29 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001d96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001d96d0 for iteration 29
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 29 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001d96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001d96d0 for iteration 29
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 30 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 30 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 30 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001e96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001e96d0 for iteration 30
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 30 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001e96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001e96d0 for iteration 30
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 31 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 31 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 31 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001f96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040001f96d0 for iteration 31
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 31 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040001f96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040001f96d0 for iteration 31
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 32 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 32 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 32 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002096d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002096d0 for iteration 32
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 32 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002096d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002096d0 for iteration 32
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 33 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 33 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 33 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002196d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002196d0 for iteration 33
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 33 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002196d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002196d0 for iteration 33
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 34 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 34 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 34 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002296d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002296d0 for iteration 34
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 34 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002296d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002296d0 for iteration 34
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 35 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 35 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 35 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002396d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002396d0 for iteration 35
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 35 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002396d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002396d0 for iteration 35
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 36 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 36 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 36 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002496d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002496d0 for iteration 36
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 36 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002496d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002496d0 for iteration 36
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 37 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 37 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 37 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002596d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002596d0 for iteration 37
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 37 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002596d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002596d0 for iteration 37
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 38 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 38 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 38 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002696d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002696d0 for iteration 38
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 38 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002696d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002696d0 for iteration 38
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 39 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 39 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 39 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002796d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002796d0 for iteration 39
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 39 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002796d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002796d0 for iteration 39
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 40 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 40 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 40 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002896d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002896d0 for iteration 40
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 40 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002896d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002896d0 for iteration 40
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 41 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 41 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 41 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002996d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002996d0 for iteration 41
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 41 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002996d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002996d0 for iteration 41
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 42 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 42 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 42 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002a96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002a96d0 for iteration 42
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 42 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002a96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002a96d0 for iteration 42
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 43 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 43 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 43 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002b96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002b96d0 for iteration 43
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 43 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002b96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002b96d0 for iteration 43
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 evaluating condition for iteration 44 (Result-based)
DEBUG: BinaryOpExpr - Lane 0 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 evaluating condition for iteration 44 (Result-based)
DEBUG: BinaryOpExpr - Lane 1 evaluating binary operation (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'i' (Result-based)
DEBUG: VariableExpr - Variable 'i' = 1
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 0 resuming Result-based while loop
DEBUG: WhileStmt - Lane 0 executing body for iteration 44 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 0 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 0 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002c96d0
DEBUG: WhileStmt - Lane 0 pushed iteration merge point 0x5040002c96d0 for iteration 44
DEBUG: WhileStmt - Lane 0 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 0 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 0 resuming Result-based if statement
DEBUG: IfStmt - Lane 0 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 0 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 0 executing continue via Result
DEBUG: WhileStmt - Lane 0 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 0 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: WhileStmt - Lane 1 resuming Result-based while loop
DEBUG: WhileStmt - Lane 1 executing body for iteration 44 from statement 0 (Result-based)
DEBUG: WhileStmt - Lane 1 no iteration block needed (first statement is control flow)
DEBUG: WhileStmt - Lane 1 merge stack size: 2
  Stack[0]: sourceStatement=0x5040000046d0
  Stack[1]: sourceStatement=0x5040000096d0
  Looking for iterationMarker=0x5040002c96d0
DEBUG: WhileStmt - Lane 1 pushed iteration merge point 0x5040002c96d0 for iteration 44
DEBUG: WhileStmt - Lane 1 executing directly in current block 2 (no iteration block needed, but merge stack modified)
DEBUG: WhileStmt - Lane 1 executing statement 0 in block 2 (Result-based)
DEBUG: IfStmt - Lane 1 resuming Result-based if statement
DEBUG: IfStmt - Lane 1 resuming execution (found at stack index=1, current stack depth=2, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 in phase ExecutingBody (Result-based, stack depth=2, our index=1, this=0x5060000016a0)
DEBUG: IfStmt - Lane 1 executing then block from statement 1 (Result-based)
DEBUG: ContinueStmt - Lane 1 executing continue via Result
DEBUG: WhileStmt - Lane 1 continuing while loop
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 4 participating lanes (0 1 2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - lane 1 already in block 2, skipping redundant assignment
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
WARNING: getCurrentBlock - Lane 2 found in multiple blocks: 2, 5 (registry returned: 5)
WARNING: getCurrentBlock - Lane 3 found in multiple blocks: 2, 5 (registry returned: 5)
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
=== Order Independence Verification ===
 PASS: Program is order-independent!
Verified across 1 different thread orderings.

 Execution completed successfully!


=== STDERR ===

=== Starting HLSL Parse with AST Ownership ===
File: /home/t-zheychen/dxc_workspace/DirectXShaderCompiler/tools/clang/tools/dxc-fuzzer/examples/control_flow_while_continue.hlsl
About to parse AST directly...
DEBUG: Captured ASTContext pointer: 0x529000000200
DEBUG: Found function: main
DEBUG: Captured main function: 0x521000050508
DEBUG: Analyzing variable reference: i
DEBUG: Variable i is a NamedDecl, checking semantics
DEBUG: Variable i is a VarDecl
DEBUG: Variable i not in cache, analyzing initialization
DEBUG: Variable i has initializer
DEBUG: Analyzing initializer for i
DEBUG: Checking initializer of type: ImplicitCastExpr
DEBUG: After IgnoreImpCasts, type is: IntegerLiteral
DEBUG: Found literal initializer - returning true
DEBUG: Initializer analysis result: deterministic
DEBUG: Cached result for i: deterministic
DEBUG: Analyzing variable reference: i
DEBUG: Variable i is a NamedDecl, checking semantics
DEBUG: Variable i is a VarDecl
DEBUG: Found i in cache: deterministic
DEBUG: Analyzing variable reference: i
DEBUG: Variable i is a NamedDecl, checking semantics
DEBUG: Variable i is a VarDecl
DEBUG: Found i in cache: deterministic
DEBUG: Analyzing variable reference: laneId
DEBUG: Variable laneId is a NamedDecl, checking semantics
DEBUG: Variable laneId is a VarDecl
DEBUG: Variable laneId not in cache, analyzing initialization
DEBUG: Variable laneId has initializer
DEBUG: Analyzing initializer for laneId
DEBUG: Checking initializer of type: CallExpr
DEBUG: After IgnoreImpCasts, type is: CallExpr
DEBUG: Unknown initializer type (CallExpr) - returning false
DEBUG: Initializer analysis result: non-deterministic
DEBUG: Cached result for laneId: non-deterministic
DEBUG: Analyzing variable reference: laneId
DEBUG: Variable laneId is a NamedDecl, checking semantics
DEBUG: Variable laneId is a VarDecl
DEBUG: Found laneId in cache: non-deterministic
collect_memory_operations_in_dbeg: Processing CompoundStmt
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing WhileStmt
collect_memory_operations_in_dbeg: Processing BinaryOperator
  Found BinaryOperator, isAssignmentOp: 0
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundStmt
collect_memory_operations_in_dbeg: Processing IfStmt
collect_memory_operations_in_dbeg: Processing BinaryOperator
  Found BinaryOperator, isAssignmentOp: 0
collect_memory_operations_in_dbeg: Processing BinaryOperator
  Found BinaryOperator, isAssignmentOp: 0
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing BinaryOperator
  Found BinaryOperator, isAssignmentOp: 0
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundStmt
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: int
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking IntegerLiteral
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing ContinueStmt
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: uint
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking CallExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: int
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking IntegerLiteral
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing CompoundStmt
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveGetLaneIndex is a barrier operation
Found wave operation: WaveGetLaneIndex
Checking if WaveGetLaneIndex is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing WhileStmt
collect_synchronization_operations_in_dbeg: Processing BinaryOperator
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundStmt
collect_synchronization_operations_in_dbeg: Processing IfStmt
collect_synchronization_operations_in_dbeg: Processing BinaryOperator
collect_synchronization_operations_in_dbeg: Processing BinaryOperator
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing BinaryOperator
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundStmt
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing ContinueStmt
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
Simplified DBEG: Single block with 32 threads and 96 memory operations

=== Cross-Dynamic-Block Analysis ===
Total memory operations: 96
Op 0: Thread 0 in DB0 wave_op
Op 1: Thread 1 in DB0 wave_op
Op 2: Thread 2 in DB0 wave_op
Op 3: Thread 3 in DB0 wave_op
Op 4: Thread 4 in DB0 wave_op
Op 5: Thread 5 in DB0 wave_op
Op 6: Thread 6 in DB0 wave_op
Op 7: Thread 7 in DB0 wave_op
Op 8: Thread 8 in DB0 wave_op
Op 9: Thread 9 in DB0 wave_op
Op 10: Thread 10 in DB0 wave_op
Op 11: Thread 11 in DB0 wave_op
Op 12: Thread 12 in DB0 wave_op
Op 13: Thread 13 in DB0 wave_op
Op 14: Thread 14 in DB0 wave_op
Op 15: Thread 15 in DB0 wave_op
Op 16: Thread 16 in DB0 wave_op
Op 17: Thread 17 in DB0 wave_op
Op 18: Thread 18 in DB0 wave_op
Op 19: Thread 19 in DB0 wave_op
Op 20: Thread 20 in DB0 wave_op
Op 21: Thread 21 in DB0 wave_op
Op 22: Thread 22 in DB0 wave_op
Op 23: Thread 23 in DB0 wave_op
Op 24: Thread 24 in DB0 wave_op
Op 25: Thread 25 in DB0 wave_op
Op 26: Thread 26 in DB0 wave_op
Op 27: Thread 27 in DB0 wave_op
Op 28: Thread 28 in DB0 wave_op
Op 29: Thread 29 in DB0 wave_op
Op 30: Thread 30 in DB0 wave_op
Op 31: Thread 31 in DB0 wave_op
Op 32: Thread 0 in DB0 wave_op
Op 33: Thread 1 in DB0 wave_op
Op 34: Thread 2 in DB0 wave_op
Op 35: Thread 3 in DB0 wave_op
Op 36: Thread 4 in DB0 wave_op
Op 37: Thread 5 in DB0 wave_op
Op 38: Thread 6 in DB0 wave_op
Op 39: Thread 7 in DB0 wave_op
Op 40: Thread 8 in DB0 wave_op
Op 41: Thread 9 in DB0 wave_op
Op 42: Thread 10 in DB0 wave_op
Op 43: Thread 11 in DB0 wave_op
Op 44: Thread 12 in DB0 wave_op
Op 45: Thread 13 in DB0 wave_op
Op 46: Thread 14 in DB0 wave_op
Op 47: Thread 15 in DB0 wave_op
Op 48: Thread 16 in DB0 wave_op
Op 49: Thread 17 in DB0 wave_op
Op 50: Thread 18 in DB0 wave_op
Op 51: Thread 19 in DB0 wave_op
Op 52: Thread 20 in DB0 wave_op
Op 53: Thread 21 in DB0 wave_op
Op 54: Thread 22 in DB0 wave_op
Op 55: Thread 23 in DB0 wave_op
Op 56: Thread 24 in DB0 wave_op
Op 57: Thread 25 in DB0 wave_op
Op 58: Thread 26 in DB0 wave_op
Op 59: Thread 27 in DB0 wave_op
Op 60: Thread 28 in DB0 wave_op
Op 61: Thread 29 in DB0 wave_op
Op 62: Thread 30 in DB0 wave_op
Op 63: Thread 31 in DB0 wave_op
Op 64: Thread 0 in DB0 wave_op
Op 65: Thread 1 in DB0 wave_op
Op 66: Thread 2 in DB0 wave_op
Op 67: Thread 3 in DB0 wave_op
Op 68: Thread 4 in DB0 wave_op
Op 69: Thread 5 in DB0 wave_op
Op 70: Thread 6 in DB0 wave_op
Op 71: Thread 7 in DB0 wave_op
Op 72: Thread 8 in DB0 wave_op
Op 73: Thread 9 in DB0 wave_op
Op 74: Thread 10 in DB0 wave_op
Op 75: Thread 11 in DB0 wave_op
Op 76: Thread 12 in DB0 wave_op
Op 77: Thread 13 in DB0 wave_op
Op 78: Thread 14 in DB0 wave_op
Op 79: Thread 15 in DB0 wave_op
Op 80: Thread 16 in DB0 wave_op
Op 81: Thread 17 in DB0 wave_op
Op 82: Thread 18 in DB0 wave_op
Op 83: Thread 19 in DB0 wave_op
Op 84: Thread 20 in DB0 wave_op
Op 85: Thread 21 in DB0 wave_op
Op 86: Thread 22 in DB0 wave_op
Op 87: Thread 23 in DB0 wave_op
Op 88: Thread 24 in DB0 wave_op
Op 89: Thread 25 in DB0 wave_op
Op 90: Thread 26 in DB0 wave_op
Op 91: Thread 27 in DB0 wave_op
Op 92: Thread 28 in DB0 wave_op
Op 93: Thread 29 in DB0 wave_op
Op 94: Thread 30 in DB0 wave_op
Op 95: Thread 31 in DB0 wave_op
SIMPLIFIED VALIDATION: Focusing on control flow determinism
Complex DBEG analysis disabled - moved to interpreter
Direct ParseAST complete
=== HLSL Parse with AST Ownership Complete ===
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
  Waking up lane 3 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
  Waking up lane 3 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready

=== Dynamic Execution Graph (MiniHLSL Interpreter) ===
Threadgroup Size: 4
Wave Size: 32
Wave Count: 1
Total Dynamic Blocks: 5
Next Block ID: 6

Dynamic Block 1:
  Block ID: 1
  Block Type: REGULAR
  Parent Block: 0
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0

Dynamic Block 2:
  Block ID: 2
  Block Type: LOOP_HEADER
  Parent Block: 1
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5040000046d0
  Participating Lanes by Wave:
    Wave 0: {0, 1, 2, 3} (4 lanes)
  Total Participating Lanes: 4
  Arrived Lanes by Wave:
    Wave 0: {0, 1, 2, 3} (4 lanes)

Dynamic Block 3:
  Block ID: 3
  Block Type: LOOP_EXIT
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5040000046d0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Unknown Lanes by Wave:
    Wave 0: {0, 1, 2, 3} (4 lanes)

Dynamic Block 4:
  Block ID: 4
  Block Type: BRANCH_THEN
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5060000016a0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Unknown Lanes by Wave:
    Wave 0: {0, 1} (2 lanes)

Dynamic Block 5:
  Block ID: 5
  Block Type: MERGE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5060000016a0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Unknown Lanes by Wave:
    Wave 0: {0, 1} (2 lanes)
  Waiting Lanes by Wave:
    Wave 0: {2, 3} (2 lanes)
  Instructions (1):
    0: WaveActiveOp (ptr: 0x503000001a50)

=== Wave States ===
Wave 0:
  Wave Size: 32
  Lane Count: 4
  Active Lanes: 4
  Currently Active Lanes: 4
  Lane to Block Mapping (from registry):
    Lane 0 -> Block 2
    Lane 1 -> Block 2
    Lane 2 -> Block 5
    Lane 3 -> Block 5
  Active Sync Points (1):
    Instruction 0x503000001a50 block 5 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No

=== End Dynamic Execution Graph ===


=== Final Variable Values ===
Wave 0:
  Lane 0:
    i = 1
    laneId = 0
    result = 0
    (state: Ready)
  Lane 1:
    i = 1
    laneId = 1
    result = 0
    (state: WaitingForResume)
  Lane 2:
    i = 0
    laneId = 2
    result = 0
    (state: WaitingForWave)
  Lane 3:
    i = 0
    laneId = 3
    result = 0
    (state: WaitingForWave)
=== End Variable Values ===

  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
  Waking up lane 3 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
  Waking up lane 3 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 0 from WaitingForResume to Ready

=== Dynamic Execution Graph (MiniHLSL Interpreter) ===
Threadgroup Size: 4
Wave Size: 32
Wave Count: 1
Total Dynamic Blocks: 5
Next Block ID: 6

Dynamic Block 1:
  Block ID: 1
  Block Type: REGULAR
  Parent Block: 0
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0

Dynamic Block 2:
  Block ID: 2
  Block Type: LOOP_HEADER
  Parent Block: 1
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5040000046d0
  Participating Lanes by Wave:
    Wave 0: {0, 1, 2, 3} (4 lanes)
  Total Participating Lanes: 4
  Arrived Lanes by Wave:
    Wave 0: {0, 1, 2, 3} (4 lanes)

Dynamic Block 3:
  Block ID: 3
  Block Type: LOOP_EXIT
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5040000046d0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Unknown Lanes by Wave:
    Wave 0: {0, 1, 2, 3} (4 lanes)

Dynamic Block 4:
  Block ID: 4
  Block Type: BRANCH_THEN
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5060000016a0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Unknown Lanes by Wave:
    Wave 0: {0, 1} (2 lanes)

Dynamic Block 5:
  Block ID: 5
  Block Type: MERGE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x5060000016a0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Unknown Lanes by Wave:
    Wave 0: {0, 1} (2 lanes)
  Waiting Lanes by Wave:
    Wave 0: {2, 3} (2 lanes)
  Instructions (1):
    0: WaveActiveOp (ptr: 0x503000001a50)

=== Wave States ===
Wave 0:
  Wave Size: 32
  Lane Count: 4
  Active Lanes: 4
  Currently Active Lanes: 4
  Lane to Block Mapping (from registry):
    Lane 0 -> Block 2
    Lane 1 -> Block 2
    Lane 2 -> Block 5
    Lane 3 -> Block 5
  Active Sync Points (1):
    Instruction 0x503000001a50 block 5 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No

=== End Dynamic Execution Graph ===


=== Final Variable Values ===
Wave 0:
  Lane 0:
    i = 1
    laneId = 0
    result = 0
    (state: Ready)
  Lane 1:
    i = 1
    laneId = 1
    result = 0
    (state: WaitingForResume)
  Lane 2:
    i = 0
    laneId = 2
    result = 0
    (state: WaitingForWave)
  Lane 3:
    i = 0
    laneId = 3
    result = 0
    (state: WaitingForWave)
=== End Variable Values ===



=== VERIFICATION ===
  totalSum: expected 21, but not found in output

