=== COMMAND ===
/home/t-zheychen/dxc_workspace/DirectXShaderCompiler/build-fuzzer/bin/minihlsl-standalone -o 1 /home/t-zheychen/dxc_workspace/DirectXShaderCompiler/tools/clang/tools/dxc-fuzzer/examples/control_flow_switch_return.hlsl

=== RETURN CODE ===
0

=== STDOUT ===
MiniHLSL Interpreter
====================
Input file: /home/t-zheychen/dxc_workspace/DirectXShaderCompiler/tools/clang/tools/dxc-fuzzer/examples/control_flow_switch_return.hlsl
Wave size: 32
Order verification: 1 orderings

Converting HLSL function: main
Found numthreads attribute: [4, 1, 1]
Converting compound statement with 5 child statements
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: laneId of type: uint
Converting expression: CallExpr of type: unsigned int
Converting function call to expression: WaveGetLaneIndex
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: result of type: uint
Converting expression: ImplicitCastExpr of type: uint
Converting expression: IntegerLiteral of type: literal int
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: i of type: int
Converting expression: ImplicitCastExpr of type: int
Converting expression: IntegerLiteral of type: literal int
Converting statement: SwitchStmt
Converting switch statement
Converting expression: ImplicitCastExpr of type: uint
Converting expression: DeclRefExpr of type: uint
DEBUG: Switch parsing - processing AST node: CaseStmt
DEBUG: Switch parsing - LHS type: ImplicitCastExpr
DEBUG: Switch parsing - found case 0
Converting statement: CompoundAssignOperator
Converting compound assignment operator: +=
Converting expression: DeclRefExpr of type: uint
Converting expression: ImplicitCastExpr of type: uint
Converting expression: CallExpr of type: literal int
Converting function call to expression: WaveActiveSum
Converting expression: IntegerLiteral of type: literal int
DEBUG: Creating AssignStmt for compound assignment: result = (result + WaveActiveSum(0))
DEBUG: Created statement type: AssignStmt with toString: result = (result + WaveActiveSum(0));
DEBUG: Switch parsing - processing AST node: CaseStmt
DEBUG: SwitchStmt::addCase - adding case 0
DEBUG: Switch parsing - LHS type: ImplicitCastExpr
DEBUG: Switch parsing - found case 1
Converting statement: CompoundAssignOperator
Converting compound assignment operator: +=
Converting expression: DeclRefExpr of type: uint
Converting expression: ImplicitCastExpr of type: uint
Converting expression: CallExpr of type: literal int
Converting function call to expression: WaveActiveSum
Converting expression: IntegerLiteral of type: literal int
DEBUG: Creating AssignStmt for compound assignment: result = (result + WaveActiveSum(1))
DEBUG: Created statement type: AssignStmt with toString: result = (result + WaveActiveSum(1));
DEBUG: Switch parsing - processing AST node: ReturnStmt
Converting statement: ReturnStmt
Converting return statement
DEBUG: Switch parsing - processing AST node: CaseStmt
DEBUG: SwitchStmt::addCase - adding case 1
DEBUG: Switch parsing - LHS type: ImplicitCastExpr
DEBUG: Switch parsing - found case 2
Converting statement: CompoundAssignOperator
Converting compound assignment operator: +=
Converting expression: DeclRefExpr of type: uint
Converting expression: ImplicitCastExpr of type: uint
Converting expression: CallExpr of type: literal int
Converting function call to expression: WaveActiveSum
Converting expression: IntegerLiteral of type: literal int
DEBUG: Creating AssignStmt for compound assignment: result = (result + WaveActiveSum(2))
DEBUG: Created statement type: AssignStmt with toString: result = (result + WaveActiveSum(2));
DEBUG: Switch parsing - processing AST node: CaseStmt
DEBUG: SwitchStmt::addCase - adding case 2
DEBUG: Switch parsing - LHS type: ImplicitCastExpr
DEBUG: Switch parsing - found case 3
Converting statement: CompoundAssignOperator
Converting compound assignment operator: +=
Converting expression: DeclRefExpr of type: uint
Converting expression: ImplicitCastExpr of type: uint
Converting expression: CallExpr of type: literal int
Converting function call to expression: WaveActiveSum
Converting expression: IntegerLiteral of type: literal int
DEBUG: Creating AssignStmt for compound assignment: result = (result + WaveActiveSum(3))
DEBUG: Created statement type: AssignStmt with toString: result = (result + WaveActiveSum(3));
DEBUG: Switch parsing - processing AST node: DefaultStmt
DEBUG: Switch parsing - found default case
DEBUG: SwitchStmt::addCase - adding case 3
Converting statement: CompoundAssignOperator
Converting compound assignment operator: +=
Converting expression: DeclRefExpr of type: uint
Converting expression: ImplicitCastExpr of type: uint
Converting expression: CallExpr of type: literal int
Converting function call to expression: WaveActiveSum
Converting expression: IntegerLiteral of type: literal int
DEBUG: Creating AssignStmt for compound assignment: result = (result + WaveActiveSum(10))
DEBUG: Created statement type: AssignStmt with toString: result = (result + WaveActiveSum(10));
DEBUG: SwitchStmt::addDefault - adding default case
Converting statement: DeclStmt
Converting declaration statement
Declaring variable: totalSum of type: uint
Converting expression: CallExpr of type: unsigned int
Converting function call to expression: WaveActiveSum
Converting expression: ImplicitCastExpr of type: uint
Converting expression: DeclRefExpr of type: uint
Converted AST to interpreter program with 5 statements
Thread configuration: [4, 1, 1]

DEBUG: findOrCreateBlockForPath called with 0 waves of unknown lanes
DEBUG: Initializing wave 0 with 4 lanes in initial block 1
DEBUG: markLaneArrived - Lane 0 transitioned from Unknown to Participating in block 1
DEBUG: Lane 0 assigned to block 1
DEBUG: markLaneArrived - Lane 1 transitioned from Unknown to Participating in block 1
DEBUG: Lane 1 assigned to block 1
DEBUG: markLaneArrived - Lane 2 transitioned from Unknown to Participating in block 1
DEBUG: Lane 2 assigned to block 1
DEBUG: markLaneArrived - Lane 3 transitioned from Unknown to Participating in block 1
DEBUG: Lane 3 assigned to block 1
DEBUG: SwitchStmt - Lane 0 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 0 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 2
DEBUG: addUnknownLane - adding lane 1 to new block 2
DEBUG: addUnknownLane - adding lane 2 to new block 2
DEBUG: addUnknownLane - adding lane 3 to new block 2
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 3
DEBUG: addUnknownLane - adding lane 1 to new block 3
DEBUG: addUnknownLane - adding lane 2 to new block 3
DEBUG: addUnknownLane - adding lane 3 to new block 3
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 4
DEBUG: addUnknownLane - adding lane 1 to new block 4
DEBUG: addUnknownLane - adding lane 2 to new block 4
DEBUG: addUnknownLane - adding lane 3 to new block 4
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 5
DEBUG: addUnknownLane - adding lane 1 to new block 5
DEBUG: addUnknownLane - adding lane 2 to new block 5
DEBUG: addUnknownLane - adding lane 3 to new block 5
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 6
DEBUG: addUnknownLane - adding lane 1 to new block 6
DEBUG: addUnknownLane - adding lane 2 to new block 6
DEBUG: addUnknownLane - adding lane 3 to new block 6
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 7
DEBUG: addUnknownLane - adding lane 1 to new block 7
DEBUG: addUnknownLane - adding lane 2 to new block 7
DEBUG: addUnknownLane - adding lane 3 to new block 7
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 8
DEBUG: addUnknownLane - adding lane 1 to new block 8
DEBUG: addUnknownLane - adding lane 2 to new block 8
DEBUG: addUnknownLane - adding lane 3 to new block 8
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 0 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: SwitchStmt - Lane 0 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 0 evaluating condition for first time
DEBUG: VariableExpr - Lane 0 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 0 (lane 0 at 0x50f000000040)
DEBUG: SwitchStmt - Lane 0 switch condition evaluated to: 0
DEBUG: SwitchStmt - Lane 0 matched case 0 at index 0
DEBUG: SwitchStmt - Lane 0 moving to case block 3 for case 0
DEBUG: SwitchStmt - Lane 0 moving from header to first case block 3 (case 0)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 3
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 3
DEBUG: assignLaneToBlock - BEFORE: block 3 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 0 from block 2 (type 7) to block 3 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 2
DEBUG: assignLaneToBlock - AFTER: block 3 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 3
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 3
DEBUG: removeThreadFromAllSets - removing lane 0 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 1 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 1 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 6 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 7 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 8 - not modifying unknown lanes
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - moving lane 1 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 1 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (1), 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - END: lane 1 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: SwitchStmt - Lane 1 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 1 evaluating condition for first time
DEBUG: VariableExpr - Lane 1 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 1 (lane 1 at 0x50f000000130)
DEBUG: SwitchStmt - Lane 1 switch condition evaluated to: 1
DEBUG: SwitchStmt - Lane 1 matched case 1 at index 1
DEBUG: SwitchStmt - Lane 1 moving to case block 4 for case 1
DEBUG: SwitchStmt - Lane 1 moving from header to first case block 4 (case 1)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 4
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 4
DEBUG: assignLaneToBlock - BEFORE: block 4 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 1 from block 2 (type 7) to block 4 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 1 from block 2
DEBUG: assignLaneToBlock - AFTER: block 4 has 1 participating lanes (1), 0 waiting lanes, 3 unknown lanes (0 2 3)
DEBUG: assignLaneToBlock - END: lane 1 successfully assigned to block 4
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 4
DEBUG: SwitchStmt - Lane 1 removing from previous case block 3 (case 0)
DEBUG: removeThreadFromUnknown - removing lane 1 from block 3
DEBUG: Block 3 unknown lanes before removal: {1 2 3}
DEBUG: Block 3 unknown lanes after removal: {2 3}
DEBUG: Block 3 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: removeThreadFromAllSets - removing lane 1 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 2 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 2 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 6 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 7 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 8 - not modifying unknown lanes
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 2
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (2), 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 2
DEBUG: SwitchStmt - Lane 2 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 2 evaluating condition for first time
DEBUG: VariableExpr - Lane 2 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 2 (lane 2 at 0x50f000000220)
DEBUG: SwitchStmt - Lane 2 switch condition evaluated to: 2
DEBUG: SwitchStmt - Lane 2 matched case 2 at index 2
DEBUG: SwitchStmt - Lane 2 moving to case block 5 for case 2
DEBUG: SwitchStmt - Lane 2 moving from header to first case block 5 (case 2)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 5
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 5
DEBUG: assignLaneToBlock - BEFORE: block 5 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 2 (type 7) to block 5 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 2
DEBUG: assignLaneToBlock - AFTER: block 5 has 1 participating lanes (2), 0 waiting lanes, 3 unknown lanes (0 1 3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 5
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 5
DEBUG: SwitchStmt - Lane 2 removing from previous case block 3 (case 0)
DEBUG: removeThreadFromUnknown - removing lane 2 from block 3
DEBUG: Block 3 unknown lanes before removal: {2 3}
DEBUG: Block 3 unknown lanes after removal: {3}
DEBUG: Block 3 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: SwitchStmt - Lane 2 removing from previous case block 4 (case 1)
DEBUG: removeThreadFromUnknown - removing lane 2 from block 4
DEBUG: Block 4 unknown lanes before removal: {0 2 3}
DEBUG: Block 4 unknown lanes after removal: {0 3}
DEBUG: Block 4 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 3 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 3 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 6 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 7 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 8 - not modifying unknown lanes
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 2
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - moving lane 3 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 2
DEBUG: SwitchStmt - Lane 3 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 3 evaluating condition for first time
DEBUG: VariableExpr - Lane 3 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 3 (lane 3 at 0x50f000000310)
DEBUG: SwitchStmt - Lane 3 switch condition evaluated to: 3
DEBUG: SwitchStmt - Lane 3 matched case 3 at index 3
DEBUG: SwitchStmt - Lane 3 moving to case block 6 for case 3
DEBUG: SwitchStmt - Lane 3 moving from header to first case block 6 (case 3)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 6
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 6
DEBUG: assignLaneToBlock - BEFORE: block 6 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 2 (type 7) to block 6 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 2
DEBUG: assignLaneToBlock - AFTER: block 6 has 1 participating lanes (3), 0 waiting lanes, 3 unknown lanes (0 1 2)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 6
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 6
DEBUG: SwitchStmt - Lane 3 removing from previous case block 3 (case 0)
DEBUG: removeThreadFromUnknown - removing lane 3 from block 3
DEBUG: Block 3 unknown lanes before removal: {3}
DEBUG: Block 3 unknown lanes after removal: {}
DEBUG: Block 3 areAllUnknownLanesResolvedForWave(0) = 1 (tracked by registry)
DEBUG: Block 3 now has all unknowns resolved for wave 0 - checking for ready wave operations
DEBUG: SwitchStmt - Lane 3 removing from previous case block 4 (case 1)
DEBUG: removeThreadFromUnknown - removing lane 3 from block 4
DEBUG: Block 4 unknown lanes before removal: {0 3}
DEBUG: Block 4 unknown lanes after removal: {0}
DEBUG: Block 4 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: SwitchStmt - Lane 3 removing from previous case block 5 (case 2)
DEBUG: removeThreadFromUnknown - removing lane 3 from block 5
DEBUG: Block 5 unknown lanes before removal: {0 1 3}
DEBUG: Block 5 unknown lanes after removal: {0 1}
DEBUG: Block 5 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: removeThreadFromAllSets - removing lane 3 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 0 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 0 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 0 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000040)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 3, instruction key=(0x506000001940,3)
DEBUG: markLaneWaitingForWave - Lane 0 wave 0 in block 3
DEBUG: markLaneWaitingForWave - Successfully set lane 0 to WaitingForWave in block 3
DEBUG: WAVE_OP: Lane 0 cannot execute, starting to wait in block 3
DEBUG: Block 3 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 0 in block 3: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 0 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 0 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Storing collective result for lanes: 0  (phase: 2)
DEBUG: SwitchStmt - Lane 1 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 1 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 1 at 0x50f000000130)
DEBUG: WAVE_OP: Lane 1 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: markLaneWaitingForWave - Lane 1 wave 0 in block 4
DEBUG: markLaneWaitingForWave - Successfully set lane 1 to WaitingForWave in block 4
DEBUG: WAVE_OP: Lane 1 cannot execute, starting to wait in block 4
DEBUG: Block 4 wave 0 unknown lanes: {0 }
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 1 in block 4: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 1 received WaveOperationWait error, state=2
DEBUG: onLaneFinishWaveOp - Lane 0 finishing wave op in block 3
DEBUG: onLaneFinishWaveOp - Current status in block 3: 2
DEBUG: onLaneFinishWaveOp - Updated lane 0 to Participating in block 3
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 2 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 2 at 0x50f000000220)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 5, instruction key=(0x506000001b20,5)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 5
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 5
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 5
DEBUG: Block 5 wave 0 unknown lanes: {0 1 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 2 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 3 at 0x50f000000310)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 6
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 6
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 6
DEBUG: Block 6 wave 0 unknown lanes: {0 1 2 }
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 6: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 0 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 0 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 0 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000040)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 3, instruction key=(0x506000001940,3)
DEBUG: WAVE_OP: Lane 0 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 0 retrieving stored wave result: 0 (phase: Consumed)
DEBUG: AssignStmt - Lane 0 assigned value 0 to variable 'result'
DEBUG: SwitchStmt - Lane 0 completed case 0, falling through to next
DEBUG: SwitchStmt - Lane 0 moving from case block 3 to case block 4 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 4
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 4
DEBUG: assignLaneToBlock - BEFORE: block 4 has 0 participating lanes, 1 waiting lanes (1), 1 unknown lanes (0)
DEBUG: assignLaneToBlock - moving lane 0 from block 3 (type 8) to block 4 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 3
DEBUG: assignLaneToBlock - AFTER: block 4 has 1 participating lanes (0), 1 waiting lanes (1), 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 4
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 4
DEBUG: removeThreadFromAllSets - removing lane 0 from all sets of block 3
DEBUG: removeThreadFromAllSets - block 3 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 3 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000040)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: markLaneWaitingForWave - Lane 0 wave 0 in block 4
DEBUG: markLaneWaitingForWave - Successfully set lane 0 to WaitingForWave in block 4
DEBUG: WAVE_OP: Lane 0 cannot execute, starting to wait in block 4
DEBUG: Block 4 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 0 in block 4: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 0 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 0 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Storing collective result for lanes: 0 1  (phase: 2)
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: onLaneFinishWaveOp - Lane 0 finishing wave op in block 4
DEBUG: onLaneFinishWaveOp - Current status in block 4: 2
DEBUG: onLaneFinishWaveOp - Updated lane 0 to Participating in block 4
DEBUG: onLaneFinishWaveOp - Lane 1 finishing wave op in block 4
DEBUG: onLaneFinishWaveOp - Current status in block 4: 2
DEBUG: onLaneFinishWaveOp - Updated lane 1 to Participating in block 4
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 1 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 1 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 1 at 0x50f000000130)
DEBUG: WAVE_OP: Lane 1 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: WAVE_OP: Lane 1 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 1 retrieving stored wave result: 2 (phase: Executed)
DEBUG: AssignStmt - Lane 1 assigned value 2 to variable 'result'
DEBUG: SwitchStmt - Lane 1 executing statement 1 in case 1 (Result-based)
DEBUG: ReturnStmt - Lane 1 executing return (Result-based)
DEBUG: Block 5 wave 0 unknown lanes: {0 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 2 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: Block 6 wave 0 unknown lanes: {0 2 }
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 6: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: updateWaveOperationStates - Lane 1 returning, checking 4 active sync points
DEBUG: updateWaveOperationStates - Sync point 0x506000001940 in block 3: wasExpected=0, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 3 isAllParticipantsKnown=1 for instruction 0x506000001940
DEBUG: updateWaveOperationStates - Sync point 0x506000001a00 in block 4: wasExpected=1, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 4 isAllParticipantsKnown=1 for instruction 0x506000001a00
DEBUG: updateWaveOperationStates - Sync point for instruction 0x506000001a00 in block 4 became complete due to lane 1 returning
DEBUG: updateWaveOperationStates - Sync point 0x506000001b20 in block 5: wasExpected=0, allParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
0
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 5 isAllParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
0 for instruction 0x506000001b20
DEBUG: updateWaveOperationStates - Sync point 0x506000001be0 in block 6: wasExpected=0, allParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
0
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 6 isAllParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
0 for instruction 0x506000001be0
DEBUG: updateWaveOperationStates - Waking up lanes waiting at instruction 0x506000001a00 in block 4
DEBUG: ReturnStmt - Return completed successfully
DEBUG: SwitchStmt - Lane 1 popping stack due to return (depth 1->0, this=0x504000004390)
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 0 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 0 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000040)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: WAVE_OP: Lane 0 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 0 retrieving stored wave result: 2 (phase: Consumed)
DEBUG: AssignStmt - Lane 0 assigned value 2 to variable 'result'
DEBUG: SwitchStmt - Lane 0 executing statement 1 in case 1 (Result-based)
DEBUG: ReturnStmt - Lane 0 executing return (Result-based)
DEBUG: Block 6 wave 0 unknown lanes: {2 }
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 6: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: updateWaveOperationStates - Lane 0 returning, checking 4 active sync points
DEBUG: updateWaveOperationStates - Sync point 0x506000001940 in block 3: wasExpected=1, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Sync point 0x506000001940 in block 3 has no participants left, marking for removal
DEBUG: updateWaveOperationStates - Sync point 0x506000001a00 in block 4: wasExpected=1, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Sync point 0x506000001a00 in block 4 has no participants left, marking for removal
DEBUG: updateWaveOperationStates - Sync point 0x506000001b20 in block 5: wasExpected=0, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Lane 0 returning: Block 5 isAllParticipantsKnown=1 for instruction 0x506000001b20
DEBUG: updateWaveOperationStates - Sync point 0x506000001be0 in block 6: wasExpected=0, allParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
0
DEBUG: updateWaveOperationStates - Lane 0 returning: Block 6 isAllParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
0 for instruction 0x506000001be0
DEBUG: updateWaveOperationStates - Waking up lanes waiting at instruction 0x506000001940 in block 3
DEBUG: updateWaveOperationStates - Waking up lanes waiting at instruction 0x506000001a00 in block 4
DEBUG: ReturnStmt - Return completed successfully
DEBUG: SwitchStmt - Lane 0 popping stack due to return (depth 1->0, this=0x504000004390)
DEBUG: processWaveOperations - Sync point 0x506000001940 in block 3 has no participants, cleaning up
DEBUG: processWaveOperations - Sync point 0x506000001a00 in block 4 has no participants, cleaning up
DEBUG: WAVE_OP: Storing collective result for lanes: 2  (phase: 2)
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 5
DEBUG: onLaneFinishWaveOp - Current status in block 5: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 5
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 2 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 2 at 0x50f000000220)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 5, instruction key=(0x506000001b20,5)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 2 (phase: Consumed)
DEBUG: AssignStmt - Lane 2 assigned value 2 to variable 'result'
DEBUG: SwitchStmt - Lane 2 completed case 2, falling through to next
DEBUG: SwitchStmt - Lane 2 moving from case block 5 to case block 6 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 6
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 6
DEBUG: assignLaneToBlock - BEFORE: block 6 has 0 participating lanes, 1 waiting lanes (3), 1 unknown lanes (2)
DEBUG: assignLaneToBlock - moving lane 2 from block 5 (type 8) to block 6 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 5
DEBUG: assignLaneToBlock - AFTER: block 6 has 1 participating lanes (2), 1 waiting lanes (3), 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 6
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 6
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 5
DEBUG: removeThreadFromAllSets - block 5 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 5 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 2 (lane 2 at 0x50f000000220)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 6
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 6
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 6
DEBUG: Block 6 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 2 in block 6: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 2 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Storing collective result for lanes: 2 3  (phase: 2)
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 6
DEBUG: onLaneFinishWaveOp - Current status in block 6: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 6
DEBUG: onLaneFinishWaveOp - Lane 3 finishing wave op in block 6
DEBUG: onLaneFinishWaveOp - Current status in block 6: 2
DEBUG: onLaneFinishWaveOp - Updated lane 3 to Participating in block 6
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 3 at 0x50f000000310)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: WAVE_OP: Lane 3 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 3 retrieving stored wave result: 6 (phase: Executed)
DEBUG: AssignStmt - Lane 3 assigned value 6 to variable 'result'
DEBUG: SwitchStmt - Lane 3 completed case 3, falling through to next
DEBUG: SwitchStmt - Lane 3 moving from case block 6 to case block 7 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 7
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 7
DEBUG: assignLaneToBlock - BEFORE: block 7 has 0 participating lanes, 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 6 (type 8) to block 7 (type 9), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 6
DEBUG: assignLaneToBlock - AFTER: block 7 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 7
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 7
DEBUG: removeThreadFromAllSets - removing lane 3 from all sets of block 6
DEBUG: removeThreadFromAllSets - block 6 had 1 participating lanes before removal (participating: 2 )
DEBUG: removeThreadFromAllSets - block 6 has 1 participating lanes after removal (participating: 2 )
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 6 (lane 3 at 0x50f000000310)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 7
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 7
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 7
DEBUG: Block 7 wave 0 unknown lanes: {2 }
DEBUG: isAllParticipantsKnown - Block 7 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 7 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 7: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: onLaneFinishWaveOp - Lane 3 finishing wave op in block 7
DEBUG: onLaneFinishWaveOp - Current status in block 7: 2
DEBUG: onLaneFinishWaveOp - Updated lane 3 to Participating in block 7
DEBUG: isAllParticipantsKnown - Block 7 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 2 (lane 2 at 0x50f000000220)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 6 (phase: Consumed)
DEBUG: AssignStmt - Lane 2 assigned value 8 to variable 'result'
DEBUG: SwitchStmt - Lane 2 completed case 3, falling through to next
DEBUG: SwitchStmt - Lane 2 moving from case block 6 to case block 7 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 7
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 7
DEBUG: assignLaneToBlock - BEFORE: block 7 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - moving lane 2 from block 6 (type 8) to block 7 (type 9), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 6
DEBUG: assignLaneToBlock - AFTER: block 7 has 2 participating lanes (2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 7
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 7
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 6
DEBUG: removeThreadFromAllSets - block 6 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 6 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 8 (lane 2 at 0x50f000000220)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 7
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 7
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 7
DEBUG: Block 7 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 2 in block 7: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 2 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Updated participants before execution to include all current block lanes: 2 3 
DEBUG: WAVE_OP: Storing collective result for lanes: 2 3  (phase: 2)
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 6 (lane 3 at 0x50f000000310)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: WAVE_OP: Lane 3 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 3 retrieving stored wave result: 20 (phase: Executed)
DEBUG: AssignStmt - Lane 3 assigned value 26 to variable 'result'
DEBUG: SwitchStmt - Lane 3 completed case default, falling through to next
DEBUG: SwitchStmt - Lane 3 completed all cases, entering reconvergence
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 7
DEBUG: onLaneFinishWaveOp - Current status in block 7: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 7
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 8 (lane 2 at 0x50f000000220)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 20 (phase: Consumed)
DEBUG: AssignStmt - Lane 2 assigned value 28 to variable 'result'
DEBUG: SwitchStmt - Lane 2 completed case default, falling through to next
DEBUG: SwitchStmt - Lane 2 completed all cases, entering reconvergence
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase Reconverging (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 reconverging from switch
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 8
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 8
DEBUG: assignLaneToBlock - BEFORE: block 8 has 0 participating lanes, 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 7 (type 9) to block 8 (type 10), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 7
DEBUG: assignLaneToBlock - AFTER: block 8 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 8
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 8
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase Reconverging (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 reconverging from switch
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 8
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 8
DEBUG: assignLaneToBlock - BEFORE: block 8 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - moving lane 2 from block 7 (type 9) to block 8 (type 10), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 7
DEBUG: assignLaneToBlock - AFTER: block 8 has 2 participating lanes (2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 8
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 8
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 8
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 8
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 8
DEBUG: Block 8 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 3 in block 8: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=0, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 8
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 8
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 8
DEBUG: Block 8 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 2 in block 8: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 2 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 28 (lane 2 at 0x50f000000220)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 26 (lane 3 at 0x50f000000310)
DEBUG: WAVE_OP: Storing collective result for lanes: 2 3  (phase: 2)
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 8
DEBUG: onLaneFinishWaveOp - Current status in block 8: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 8
DEBUG: onLaneFinishWaveOp - Lane 3 finishing wave op in block 8
DEBUG: onLaneFinishWaveOp - Current status in block 8: 2
DEBUG: onLaneFinishWaveOp - Updated lane 3 to Participating in block 8
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: WAVE_OP: Lane 3 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 3 retrieving stored wave result: 54 (phase: Executed)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 54 (phase: Consumed)
lane 3 have completed execution
lane 2 have completed execution
=== Sequential Execution ===
✅ Execution successful
Thread Return Values:
  Thread 0: 0
  Thread 1: 0
  Thread 2: 0
  Thread 3: 0

DEBUG: findOrCreateBlockForPath called with 0 waves of unknown lanes
DEBUG: Initializing wave 0 with 4 lanes in initial block 1
DEBUG: markLaneArrived - Lane 0 transitioned from Unknown to Participating in block 1
DEBUG: Lane 0 assigned to block 1
DEBUG: markLaneArrived - Lane 1 transitioned from Unknown to Participating in block 1
DEBUG: Lane 1 assigned to block 1
DEBUG: markLaneArrived - Lane 2 transitioned from Unknown to Participating in block 1
DEBUG: Lane 2 assigned to block 1
DEBUG: markLaneArrived - Lane 3 transitioned from Unknown to Participating in block 1
DEBUG: Lane 3 assigned to block 1
DEBUG: SwitchStmt - Lane 0 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 0 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 2
DEBUG: addUnknownLane - adding lane 1 to new block 2
DEBUG: addUnknownLane - adding lane 2 to new block 2
DEBUG: addUnknownLane - adding lane 3 to new block 2
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 3
DEBUG: addUnknownLane - adding lane 1 to new block 3
DEBUG: addUnknownLane - adding lane 2 to new block 3
DEBUG: addUnknownLane - adding lane 3 to new block 3
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 4
DEBUG: addUnknownLane - adding lane 1 to new block 4
DEBUG: addUnknownLane - adding lane 2 to new block 4
DEBUG: addUnknownLane - adding lane 3 to new block 4
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 5
DEBUG: addUnknownLane - adding lane 1 to new block 5
DEBUG: addUnknownLane - adding lane 2 to new block 5
DEBUG: addUnknownLane - adding lane 3 to new block 5
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 6
DEBUG: addUnknownLane - adding lane 1 to new block 6
DEBUG: addUnknownLane - adding lane 2 to new block 6
DEBUG: addUnknownLane - adding lane 3 to new block 6
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 7
DEBUG: addUnknownLane - adding lane 1 to new block 7
DEBUG: addUnknownLane - adding lane 2 to new block 7
DEBUG: addUnknownLane - adding lane 3 to new block 7
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {0 1 2 3 } (4 lanes)
DEBUG: addUnknownLane - adding lane 0 to new block 8
DEBUG: addUnknownLane - adding lane 1 to new block 8
DEBUG: addUnknownLane - adding lane 2 to new block 8
DEBUG: addUnknownLane - adding lane 3 to new block 8
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 2
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 0 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 2
DEBUG: SwitchStmt - Lane 0 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 0 evaluating condition for first time
DEBUG: VariableExpr - Lane 0 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 0 (lane 0 at 0x50f000000400)
DEBUG: SwitchStmt - Lane 0 switch condition evaluated to: 0
DEBUG: SwitchStmt - Lane 0 matched case 0 at index 0
DEBUG: SwitchStmt - Lane 0 moving to case block 3 for case 0
DEBUG: SwitchStmt - Lane 0 moving from header to first case block 3 (case 0)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 3
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 3
DEBUG: assignLaneToBlock - BEFORE: block 3 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 0 from block 2 (type 7) to block 3 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 2
DEBUG: assignLaneToBlock - AFTER: block 3 has 1 participating lanes (0), 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 3
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 3
DEBUG: removeThreadFromAllSets - removing lane 0 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 1 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 1 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 6 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 7 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {1 2 3 } (3 lanes)
DEBUG: Found existing block 8 - not modifying unknown lanes
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 2
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 3 unknown lanes (1 2 3)
DEBUG: assignLaneToBlock - moving lane 1 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 1 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (1), 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - END: lane 1 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 2
DEBUG: SwitchStmt - Lane 1 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 1 evaluating condition for first time
DEBUG: VariableExpr - Lane 1 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 1 (lane 1 at 0x50f0000004f0)
DEBUG: SwitchStmt - Lane 1 switch condition evaluated to: 1
DEBUG: SwitchStmt - Lane 1 matched case 1 at index 1
DEBUG: SwitchStmt - Lane 1 moving to case block 4 for case 1
DEBUG: SwitchStmt - Lane 1 moving from header to first case block 4 (case 1)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 1 to block 4
DEBUG: assignLaneToBlock - START: lane 1 being assigned to block 4
DEBUG: assignLaneToBlock - BEFORE: block 4 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 1 from block 2 (type 7) to block 4 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 1 from block 2
DEBUG: assignLaneToBlock - AFTER: block 4 has 1 participating lanes (1), 0 waiting lanes, 3 unknown lanes (0 2 3)
DEBUG: assignLaneToBlock - END: lane 1 successfully assigned to block 4
DEBUG: moveThreadFromUnknownToParticipating - lane 1 is now in block 4
DEBUG: SwitchStmt - Lane 1 removing from previous case block 3 (case 0)
DEBUG: removeThreadFromUnknown - removing lane 1 from block 3
DEBUG: Block 3 unknown lanes before removal: {1 2 3}
DEBUG: Block 3 unknown lanes after removal: {2 3}
DEBUG: Block 3 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: removeThreadFromAllSets - removing lane 1 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 2 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 2 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 6 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 7 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {2 3 } (2 lanes)
DEBUG: Found existing block 8 - not modifying unknown lanes
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 2
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (2), 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 2
DEBUG: SwitchStmt - Lane 2 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 2 evaluating condition for first time
DEBUG: VariableExpr - Lane 2 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 2 (lane 2 at 0x50f0000005e0)
DEBUG: SwitchStmt - Lane 2 switch condition evaluated to: 2
DEBUG: SwitchStmt - Lane 2 matched case 2 at index 2
DEBUG: SwitchStmt - Lane 2 moving to case block 5 for case 2
DEBUG: SwitchStmt - Lane 2 moving from header to first case block 5 (case 2)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 5
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 5
DEBUG: assignLaneToBlock - BEFORE: block 5 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 2 from block 2 (type 7) to block 5 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 2
DEBUG: assignLaneToBlock - AFTER: block 5 has 1 participating lanes (2), 0 waiting lanes, 3 unknown lanes (0 1 3)
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 5
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 5
DEBUG: SwitchStmt - Lane 2 removing from previous case block 3 (case 0)
DEBUG: removeThreadFromUnknown - removing lane 2 from block 3
DEBUG: Block 3 unknown lanes before removal: {2 3}
DEBUG: Block 3 unknown lanes after removal: {3}
DEBUG: Block 3 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: SwitchStmt - Lane 2 removing from previous case block 4 (case 1)
DEBUG: removeThreadFromUnknown - removing lane 2 from block 4
DEBUG: Block 4 unknown lanes before removal: {0 2 3}
DEBUG: Block 4 unknown lanes after removal: {0 3}
DEBUG: Block 4 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 3 starting Result-based switch statement
DEBUG: SwitchStmt - Lane 3 starting fresh execution (pushed to stack depth=1, this=0x504000004390)
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 2 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 3 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 4 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 5 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 6 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 7 - not modifying unknown lanes
DEBUG: findOrCreateBlockForPath called with 1 waves of unknown lanes
  Wave 0: {3 } (1 lanes)
DEBUG: Found existing block 8 - not modifying unknown lanes
DEBUG: SwitchStmt - Created header block 2, 5 case blocks, and merge block 8
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 2
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 2
DEBUG: assignLaneToBlock - BEFORE: block 2 has 0 participating lanes, 0 waiting lanes, 1 unknown lanes (3)
DEBUG: assignLaneToBlock - moving lane 3 from block 1 (type 0) to block 2 (type 7), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 1
DEBUG: assignLaneToBlock - AFTER: block 2 has 1 participating lanes (3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 2
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 2
DEBUG: SwitchStmt - Lane 3 in phase EvaluatingCondition (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 evaluating switch condition (Result-based)
DEBUG: SwitchStmt - Lane 3 evaluating condition for first time
DEBUG: VariableExpr - Lane 3 evaluating variable 'laneId' (Result-based)
DEBUG: VariableExpr - Variable 'laneId' = 3 (lane 3 at 0x50f0000006d0)
DEBUG: SwitchStmt - Lane 3 switch condition evaluated to: 3
DEBUG: SwitchStmt - Lane 3 matched case 3 at index 3
DEBUG: SwitchStmt - Lane 3 moving to case block 6 for case 3
DEBUG: SwitchStmt - Lane 3 moving from header to first case block 6 (case 3)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 6
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 6
DEBUG: assignLaneToBlock - BEFORE: block 6 has 0 participating lanes, 0 waiting lanes, 4 unknown lanes (0 1 2 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 2 (type 7) to block 6 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 2
DEBUG: assignLaneToBlock - AFTER: block 6 has 1 participating lanes (3), 0 waiting lanes, 3 unknown lanes (0 1 2)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 6
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 6
DEBUG: SwitchStmt - Lane 3 removing from previous case block 3 (case 0)
DEBUG: removeThreadFromUnknown - removing lane 3 from block 3
DEBUG: Block 3 unknown lanes before removal: {3}
DEBUG: Block 3 unknown lanes after removal: {}
DEBUG: Block 3 areAllUnknownLanesResolvedForWave(0) = 1 (tracked by registry)
DEBUG: Block 3 now has all unknowns resolved for wave 0 - checking for ready wave operations
DEBUG: SwitchStmt - Lane 3 removing from previous case block 4 (case 1)
DEBUG: removeThreadFromUnknown - removing lane 3 from block 4
DEBUG: Block 4 unknown lanes before removal: {0 3}
DEBUG: Block 4 unknown lanes after removal: {0}
DEBUG: Block 4 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: SwitchStmt - Lane 3 removing from previous case block 5 (case 2)
DEBUG: removeThreadFromUnknown - removing lane 3 from block 5
DEBUG: Block 5 unknown lanes before removal: {0 1 3}
DEBUG: Block 5 unknown lanes after removal: {0 1}
DEBUG: Block 5 areAllUnknownLanesResolvedForWave(0) = 0 (tracked by registry)
DEBUG: removeThreadFromAllSets - removing lane 3 from all sets of block 2
DEBUG: removeThreadFromAllSets - block 2 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 2 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 0 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 0 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 0 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000400)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 3, instruction key=(0x506000001940,3)
DEBUG: markLaneWaitingForWave - Lane 0 wave 0 in block 3
DEBUG: markLaneWaitingForWave - Successfully set lane 0 to WaitingForWave in block 3
DEBUG: WAVE_OP: Lane 0 cannot execute, starting to wait in block 3
DEBUG: Block 3 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 0 in block 3: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 0 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 0 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Storing collective result for lanes: 0  (phase: 2)
DEBUG: SwitchStmt - Lane 1 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 1 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 1 at 0x50f0000004f0)
DEBUG: WAVE_OP: Lane 1 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: markLaneWaitingForWave - Lane 1 wave 0 in block 4
DEBUG: markLaneWaitingForWave - Successfully set lane 1 to WaitingForWave in block 4
DEBUG: WAVE_OP: Lane 1 cannot execute, starting to wait in block 4
DEBUG: Block 4 wave 0 unknown lanes: {0 }
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 1 in block 4: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 1 received WaveOperationWait error, state=2
DEBUG: onLaneFinishWaveOp - Lane 0 finishing wave op in block 3
DEBUG: onLaneFinishWaveOp - Current status in block 3: 2
DEBUG: onLaneFinishWaveOp - Updated lane 0 to Participating in block 3
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 2 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 2 at 0x50f0000005e0)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 5, instruction key=(0x506000001b20,5)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 5
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 5
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 5
DEBUG: Block 5 wave 0 unknown lanes: {0 1 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 2 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 3 at 0x50f0000006d0)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 6
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 6
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 6
DEBUG: Block 6 wave 0 unknown lanes: {0 1 2 }
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 6: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: isAllParticipantsKnown - Block 4 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 0 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 0 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 0 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000400)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 3, instruction key=(0x506000001940,3)
DEBUG: WAVE_OP: Lane 0 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 0 retrieving stored wave result: 0 (phase: Consumed)
DEBUG: AssignStmt - Lane 0 assigned value 0 to variable 'result'
DEBUG: SwitchStmt - Lane 0 completed case 0, falling through to next
DEBUG: SwitchStmt - Lane 0 moving from case block 3 to case block 4 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 0 to block 4
DEBUG: assignLaneToBlock - START: lane 0 being assigned to block 4
DEBUG: assignLaneToBlock - BEFORE: block 4 has 0 participating lanes, 1 waiting lanes (1), 1 unknown lanes (0)
DEBUG: assignLaneToBlock - moving lane 0 from block 3 (type 8) to block 4 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 0 from block 3
DEBUG: assignLaneToBlock - AFTER: block 4 has 1 participating lanes (0), 1 waiting lanes (1), 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 0 successfully assigned to block 4
DEBUG: moveThreadFromUnknownToParticipating - lane 0 is now in block 4
DEBUG: removeThreadFromAllSets - removing lane 0 from all sets of block 3
DEBUG: removeThreadFromAllSets - block 3 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 3 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000400)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: markLaneWaitingForWave - Lane 0 wave 0 in block 4
DEBUG: markLaneWaitingForWave - Successfully set lane 0 to WaitingForWave in block 4
DEBUG: WAVE_OP: Lane 0 cannot execute, starting to wait in block 4
DEBUG: Block 4 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 0 in block 4: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 0 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 0 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Storing collective result for lanes: 0 1  (phase: 2)
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: onLaneFinishWaveOp - Lane 0 finishing wave op in block 4
DEBUG: onLaneFinishWaveOp - Current status in block 4: 2
DEBUG: onLaneFinishWaveOp - Updated lane 0 to Participating in block 4
DEBUG: onLaneFinishWaveOp - Lane 1 finishing wave op in block 4
DEBUG: onLaneFinishWaveOp - Current status in block 4: 2
DEBUG: onLaneFinishWaveOp - Updated lane 1 to Participating in block 4
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 2 unknown lanes: 0 1  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 3 unknown lanes: 0 1 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 1 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 1 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 1 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 1 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 1 at 0x50f0000004f0)
DEBUG: WAVE_OP: Lane 1 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: WAVE_OP: Lane 1 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 1 retrieving stored wave result: 2 (phase: Executed)
DEBUG: AssignStmt - Lane 1 assigned value 2 to variable 'result'
DEBUG: SwitchStmt - Lane 1 executing statement 1 in case 1 (Result-based)
DEBUG: ReturnStmt - Lane 1 executing return (Result-based)
DEBUG: Block 5 wave 0 unknown lanes: {0 }
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 2 in block 5: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: Block 6 wave 0 unknown lanes: {0 2 }
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 6: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: updateWaveOperationStates - Lane 1 returning, checking 4 active sync points
DEBUG: updateWaveOperationStates - Sync point 0x506000001940 in block 3: wasExpected=0, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 3 isAllParticipantsKnown=1 for instruction 0x506000001940
DEBUG: updateWaveOperationStates - Sync point 0x506000001a00 in block 4: wasExpected=1, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 4 isAllParticipantsKnown=1 for instruction 0x506000001a00
DEBUG: updateWaveOperationStates - Sync point for instruction 0x506000001a00 in block 4 became complete due to lane 1 returning
DEBUG: updateWaveOperationStates - Sync point 0x506000001b20 in block 5: wasExpected=0, allParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
0
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 5 isAllParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
0 for instruction 0x506000001b20
DEBUG: updateWaveOperationStates - Sync point 0x506000001be0 in block 6: wasExpected=0, allParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
0
DEBUG: updateWaveOperationStates - Lane 1 returning: Block 6 isAllParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
0 for instruction 0x506000001be0
DEBUG: updateWaveOperationStates - Waking up lanes waiting at instruction 0x506000001a00 in block 4
DEBUG: ReturnStmt - Return completed successfully
DEBUG: SwitchStmt - Lane 1 popping stack due to return (depth 1->0, this=0x504000004390)
DEBUG: isAllParticipantsKnown - Block 5 wave 0 has 1 unknown lanes: 0  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 2 unknown lanes: 0 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 0 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 0 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 0 executing statement 0 in case 1 (Result-based)
DEBUG: VariableExpr - Lane 0 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 0 at 0x50f000000400)
DEBUG: WAVE_OP: Lane 0 executing WaveActiveSum in block 4, instruction key=(0x506000001a00,4)
DEBUG: WAVE_OP: Lane 0 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 0 retrieving stored wave result: 2 (phase: Consumed)
DEBUG: AssignStmt - Lane 0 assigned value 2 to variable 'result'
DEBUG: SwitchStmt - Lane 0 executing statement 1 in case 1 (Result-based)
DEBUG: ReturnStmt - Lane 0 executing return (Result-based)
DEBUG: Block 6 wave 0 unknown lanes: {2 }
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 6: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: updateWaveOperationStates - Lane 0 returning, checking 4 active sync points
DEBUG: updateWaveOperationStates - Sync point 0x506000001940 in block 3: wasExpected=1, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Sync point 0x506000001940 in block 3 has no participants left, marking for removal
DEBUG: updateWaveOperationStates - Sync point 0x506000001a00 in block 4: wasExpected=1, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Sync point 0x506000001a00 in block 4 has no participants left, marking for removal
DEBUG: updateWaveOperationStates - Sync point 0x506000001b20 in block 5: wasExpected=0, allParticipantsKnown=1
DEBUG: updateWaveOperationStates - Lane 0 returning: Block 5 isAllParticipantsKnown=1 for instruction 0x506000001b20
DEBUG: updateWaveOperationStates - Sync point 0x506000001be0 in block 6: wasExpected=0, allParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
0
DEBUG: updateWaveOperationStates - Lane 0 returning: Block 6 isAllParticipantsKnown=DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
0 for instruction 0x506000001be0
DEBUG: updateWaveOperationStates - Waking up lanes waiting at instruction 0x506000001940 in block 3
DEBUG: updateWaveOperationStates - Waking up lanes waiting at instruction 0x506000001a00 in block 4
DEBUG: ReturnStmt - Return completed successfully
DEBUG: SwitchStmt - Lane 0 popping stack due to return (depth 1->0, this=0x504000004390)
DEBUG: processWaveOperations - Sync point 0x506000001940 in block 3 has no participants, cleaning up
DEBUG: processWaveOperations - Sync point 0x506000001a00 in block 4 has no participants, cleaning up
DEBUG: WAVE_OP: Storing collective result for lanes: 2  (phase: 2)
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 5
DEBUG: onLaneFinishWaveOp - Current status in block 5: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 5
DEBUG: isAllParticipantsKnown - Block 6 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 2 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 2 at 0x50f0000005e0)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 5, instruction key=(0x506000001b20,5)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 2 (phase: Consumed)
DEBUG: AssignStmt - Lane 2 assigned value 2 to variable 'result'
DEBUG: SwitchStmt - Lane 2 completed case 2, falling through to next
DEBUG: SwitchStmt - Lane 2 moving from case block 5 to case block 6 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 6
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 6
DEBUG: assignLaneToBlock - BEFORE: block 6 has 0 participating lanes, 1 waiting lanes (3), 1 unknown lanes (2)
DEBUG: assignLaneToBlock - moving lane 2 from block 5 (type 8) to block 6 (type 8), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 5
DEBUG: assignLaneToBlock - AFTER: block 6 has 1 participating lanes (2), 1 waiting lanes (3), 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 6
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 6
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 5
DEBUG: removeThreadFromAllSets - block 5 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 5 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 2 (lane 2 at 0x50f0000005e0)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 6
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 6
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 6
DEBUG: Block 6 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 2 in block 6: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 2 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Storing collective result for lanes: 2 3  (phase: 2)
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 6
DEBUG: onLaneFinishWaveOp - Current status in block 6: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 6
DEBUG: onLaneFinishWaveOp - Lane 3 finishing wave op in block 6
DEBUG: onLaneFinishWaveOp - Current status in block 6: 2
DEBUG: onLaneFinishWaveOp - Updated lane 3 to Participating in block 6
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 0 (lane 3 at 0x50f0000006d0)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: WAVE_OP: Lane 3 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 3 retrieving stored wave result: 6 (phase: Executed)
DEBUG: AssignStmt - Lane 3 assigned value 6 to variable 'result'
DEBUG: SwitchStmt - Lane 3 completed case 3, falling through to next
DEBUG: SwitchStmt - Lane 3 moving from case block 6 to case block 7 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 7
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 7
DEBUG: assignLaneToBlock - BEFORE: block 7 has 0 participating lanes, 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 6 (type 8) to block 7 (type 9), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 6
DEBUG: assignLaneToBlock - AFTER: block 7 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 7
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 7
DEBUG: removeThreadFromAllSets - removing lane 3 from all sets of block 6
DEBUG: removeThreadFromAllSets - block 6 had 1 participating lanes before removal (participating: 2 )
DEBUG: removeThreadFromAllSets - block 6 has 1 participating lanes after removal (participating: 2 )
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 6 (lane 3 at 0x50f0000006d0)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 7
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 7
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 7
DEBUG: Block 7 wave 0 unknown lanes: {2 }
DEBUG: isAllParticipantsKnown - Block 7 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: isAllParticipantsKnown - Block 7 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: canExecuteWaveInstruction for lane 3 in block 7: canExecuteInBlock=0, allParticipantsKnown=0, allParticipantsArrived=1, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: onLaneFinishWaveOp - Lane 3 finishing wave op in block 7
DEBUG: onLaneFinishWaveOp - Current status in block 7: 2
DEBUG: onLaneFinishWaveOp - Updated lane 3 to Participating in block 7
DEBUG: isAllParticipantsKnown - Block 7 wave 0 has 1 unknown lanes: 2  - These lanes need to be resolved to Participating or Left
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case 3 (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 2 (lane 2 at 0x50f0000005e0)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 6, instruction key=(0x506000001be0,6)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 6 (phase: Consumed)
DEBUG: AssignStmt - Lane 2 assigned value 8 to variable 'result'
DEBUG: SwitchStmt - Lane 2 completed case 3, falling through to next
DEBUG: SwitchStmt - Lane 2 moving from case block 6 to case block 7 (fallthrough)
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 7
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 7
DEBUG: assignLaneToBlock - BEFORE: block 7 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - moving lane 2 from block 6 (type 8) to block 7 (type 9), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 6
DEBUG: assignLaneToBlock - AFTER: block 7 has 2 participating lanes (2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 7
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 7
DEBUG: removeThreadFromAllSets - removing lane 2 from all sets of block 6
DEBUG: removeThreadFromAllSets - block 6 had 0 participating lanes before removal
DEBUG: removeThreadFromAllSets - block 6 has 0 participating lanes after removal
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 8 (lane 2 at 0x50f0000005e0)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 7
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 7
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 7
DEBUG: Block 7 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 2 in block 7: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 2 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Updated participants before execution to include all current block lanes: 2 3 
DEBUG: WAVE_OP: Storing collective result for lanes: 2 3  (phase: 2)
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 6 (lane 3 at 0x50f0000006d0)
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: WAVE_OP: Lane 3 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 3 retrieving stored wave result: 20 (phase: Executed)
DEBUG: AssignStmt - Lane 3 assigned value 26 to variable 'result'
DEBUG: SwitchStmt - Lane 3 completed case default, falling through to next
DEBUG: SwitchStmt - Lane 3 completed all cases, entering reconvergence
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 7
DEBUG: onLaneFinishWaveOp - Current status in block 7: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 7
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase ExecutingCase (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 executing statement 0 in case default (Result-based)
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 8 (lane 2 at 0x50f0000005e0)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 7, instruction key=(0x506000001ca0,7)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 20 (phase: Consumed)
DEBUG: AssignStmt - Lane 2 assigned value 28 to variable 'result'
DEBUG: SwitchStmt - Lane 2 completed case default, falling through to next
DEBUG: SwitchStmt - Lane 2 completed all cases, entering reconvergence
DEBUG: SwitchStmt - Lane 3 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 3 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 in phase Reconverging (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 3 reconverging from switch
DEBUG: moveThreadFromUnknownToParticipating - moving lane 3 to block 8
DEBUG: assignLaneToBlock - START: lane 3 being assigned to block 8
DEBUG: assignLaneToBlock - BEFORE: block 8 has 0 participating lanes, 0 waiting lanes, 2 unknown lanes (2 3)
DEBUG: assignLaneToBlock - moving lane 3 from block 7 (type 9) to block 8 (type 10), isHeaderToLoopBody=0
DEBUG: Removed lane 3 from block 7
DEBUG: assignLaneToBlock - AFTER: block 8 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - END: lane 3 successfully assigned to block 8
DEBUG: moveThreadFromUnknownToParticipating - lane 3 is now in block 8
DEBUG: SwitchStmt - Lane 2 resuming Result-based switch statement
DEBUG: SwitchStmt - Lane 2 resuming execution (found at stack index=0, current stack depth=1, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 in phase Reconverging (Result-based, stack depth=1, our index=0, this=0x504000004390)
DEBUG: SwitchStmt - Lane 2 reconverging from switch
DEBUG: moveThreadFromUnknownToParticipating - moving lane 2 to block 8
DEBUG: assignLaneToBlock - START: lane 2 being assigned to block 8
DEBUG: assignLaneToBlock - BEFORE: block 8 has 1 participating lanes (3), 0 waiting lanes, 1 unknown lanes (2)
DEBUG: assignLaneToBlock - moving lane 2 from block 7 (type 9) to block 8 (type 10), isHeaderToLoopBody=0
DEBUG: Removed lane 2 from block 7
DEBUG: assignLaneToBlock - AFTER: block 8 has 2 participating lanes (2 3), 0 waiting lanes, 0 unknown lanes
DEBUG: assignLaneToBlock - END: lane 2 successfully assigned to block 8
DEBUG: moveThreadFromUnknownToParticipating - lane 2 is now in block 8
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: markLaneWaitingForWave - Lane 3 wave 0 in block 8
DEBUG: markLaneWaitingForWave - Successfully set lane 3 to WaitingForWave in block 8
DEBUG: WAVE_OP: Lane 3 cannot execute, starting to wait in block 8
DEBUG: Block 8 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 3 in block 8: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=0, canExecuteGlobal=0, syncPointPhase=phase_0
DEBUG: WAVE_WAIT: Lane 3 received WaveOperationWait error, state=2
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: markLaneWaitingForWave - Lane 2 wave 0 in block 8
DEBUG: markLaneWaitingForWave - Successfully set lane 2 to WaitingForWave in block 8
DEBUG: WAVE_OP: Lane 2 cannot execute, starting to wait in block 8
DEBUG: Block 8 wave 0 unknown lanes: {}
DEBUG: areAllParticipantsKnownForWaveInstruction - All participants known for sync point
DEBUG: canExecuteWaveInstruction for lane 2 in block 8: canExecuteInBlock=1, allParticipantsKnown=1, allParticipantsArrived=1, canExecuteGlobal=1, syncPointPhase=phase_1
DEBUG: WAVE_OP: After lane 2 started waiting, wave operation can now execute!
DEBUG: WAVE_WAIT: Lane 2 received WaveOperationWait error, state=2
DEBUG: VariableExpr - Lane 2 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 28 (lane 2 at 0x50f0000005e0)
DEBUG: VariableExpr - Lane 3 evaluating variable 'result' (Result-based)
DEBUG: VariableExpr - Variable 'result' = 26 (lane 3 at 0x50f0000006d0)
DEBUG: WAVE_OP: Storing collective result for lanes: 2 3  (phase: 2)
DEBUG: onLaneFinishWaveOp - Lane 2 finishing wave op in block 8
DEBUG: onLaneFinishWaveOp - Current status in block 8: 2
DEBUG: onLaneFinishWaveOp - Updated lane 2 to Participating in block 8
DEBUG: onLaneFinishWaveOp - Lane 3 finishing wave op in block 8
DEBUG: onLaneFinishWaveOp - Current status in block 8: 2
DEBUG: onLaneFinishWaveOp - Updated lane 3 to Participating in block 8
DEBUG: WAVE_OP: Lane 3 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: WAVE_OP: Lane 3 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 3 retrieving stored wave result: 54 (phase: Executed)
DEBUG: WAVE_OP: Lane 2 executing WaveActiveSum in block 8, instruction key=(0x506000001d60,8)
DEBUG: WAVE_OP: Lane 2 is resuming from wave operation, checking for stored result
DEBUG: WAVE_OP: Lane 2 retrieving stored wave result: 54 (phase: Consumed)
lane 3 have completed execution
lane 2 have completed execution
=== Order Independence Verification ===
✅ PASS: Program is order-independent!
Verified across 1 different thread orderings.

✅ Execution completed successfully!


=== STDERR ===

=== Starting HLSL Parse with AST Ownership ===
File: /home/t-zheychen/dxc_workspace/DirectXShaderCompiler/tools/clang/tools/dxc-fuzzer/examples/control_flow_switch_return.hlsl
About to parse AST directly...
DEBUG: Captured ASTContext pointer: 0x529000000200
DEBUG: Found function: main
DEBUG: Captured main function: 0x521000050508
DEBUG: Analyzing variable reference: laneId
DEBUG: Variable laneId is a NamedDecl, checking semantics
DEBUG: Variable laneId is a VarDecl
DEBUG: Variable laneId not in cache, analyzing initialization
DEBUG: Variable laneId has initializer
DEBUG: Analyzing initializer for laneId
DEBUG: Checking initializer of type: CallExpr
DEBUG: After IgnoreImpCasts, type is: CallExpr
DEBUG: Unknown initializer type (CallExpr) - returning false
DEBUG: Initializer analysis result: non-deterministic
DEBUG: Cached result for laneId: non-deterministic
DEBUG: Analyzing variable reference: laneId
DEBUG: Variable laneId is a NamedDecl, checking semantics
DEBUG: Variable laneId is a VarDecl
DEBUG: Found laneId in cache: non-deterministic
collect_memory_operations_in_dbeg: Processing CompoundStmt
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing SwitchStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing CompoundStmt
collect_memory_operations_in_dbeg: Processing CaseStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: uint
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking CallExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CaseStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: uint
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking CallExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing ReturnStmt
collect_memory_operations_in_dbeg: Processing CaseStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: uint
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking CallExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CaseStmt
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: uint
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking CallExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing DefaultStmt
collect_memory_operations_in_dbeg: Processing CompoundAssignOperator
  Found BinaryOperator, isAssignmentOp: 1
  LHS type: DeclRefExpr
    is_shared_memory_access: checking DeclRefExpr
    Found DeclRefExpr
    Variable type: uint
  is_shared_memory_access(lhs): 0
    is_shared_memory_access: checking CallExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing IntegerLiteral
collect_memory_operations_in_dbeg: Processing DeclStmt
collect_memory_operations_in_dbeg: Processing CallExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_memory_operations_in_dbeg: Processing ImplicitCastExpr
collect_memory_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing CompoundStmt
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveGetLaneIndex is a barrier operation
Found wave operation: WaveGetLaneIndex
Checking if WaveGetLaneIndex is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing SwitchStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing CompoundStmt
collect_synchronization_operations_in_dbeg: Processing CaseStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CaseStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing ReturnStmt
collect_synchronization_operations_in_dbeg: Processing CaseStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CaseStmt
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing DefaultStmt
collect_synchronization_operations_in_dbeg: Processing CompoundAssignOperator
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing IntegerLiteral
collect_synchronization_operations_in_dbeg: Processing DeclStmt
collect_synchronization_operations_in_dbeg: Processing CallExpr
Checking if WaveActiveSum is a barrier operation
Found wave operation: WaveActiveSum
Checking if WaveActiveSum is a barrier operation
Found wave_operation call - adding to DBEG
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
collect_synchronization_operations_in_dbeg: Processing ImplicitCastExpr
collect_synchronization_operations_in_dbeg: Processing DeclRefExpr
Simplified DBEG: Single block with 32 threads and 224 memory operations

=== Cross-Dynamic-Block Analysis ===
Total memory operations: 224
Op 0: Thread 0 in DB0 wave_op
Op 1: Thread 1 in DB0 wave_op
Op 2: Thread 2 in DB0 wave_op
Op 3: Thread 3 in DB0 wave_op
Op 4: Thread 4 in DB0 wave_op
Op 5: Thread 5 in DB0 wave_op
Op 6: Thread 6 in DB0 wave_op
Op 7: Thread 7 in DB0 wave_op
Op 8: Thread 8 in DB0 wave_op
Op 9: Thread 9 in DB0 wave_op
Op 10: Thread 10 in DB0 wave_op
Op 11: Thread 11 in DB0 wave_op
Op 12: Thread 12 in DB0 wave_op
Op 13: Thread 13 in DB0 wave_op
Op 14: Thread 14 in DB0 wave_op
Op 15: Thread 15 in DB0 wave_op
Op 16: Thread 16 in DB0 wave_op
Op 17: Thread 17 in DB0 wave_op
Op 18: Thread 18 in DB0 wave_op
Op 19: Thread 19 in DB0 wave_op
Op 20: Thread 20 in DB0 wave_op
Op 21: Thread 21 in DB0 wave_op
Op 22: Thread 22 in DB0 wave_op
Op 23: Thread 23 in DB0 wave_op
Op 24: Thread 24 in DB0 wave_op
Op 25: Thread 25 in DB0 wave_op
Op 26: Thread 26 in DB0 wave_op
Op 27: Thread 27 in DB0 wave_op
Op 28: Thread 28 in DB0 wave_op
Op 29: Thread 29 in DB0 wave_op
Op 30: Thread 30 in DB0 wave_op
Op 31: Thread 31 in DB0 wave_op
Op 32: Thread 0 in DB0 wave_op
Op 33: Thread 1 in DB0 wave_op
Op 34: Thread 2 in DB0 wave_op
Op 35: Thread 3 in DB0 wave_op
Op 36: Thread 4 in DB0 wave_op
Op 37: Thread 5 in DB0 wave_op
Op 38: Thread 6 in DB0 wave_op
Op 39: Thread 7 in DB0 wave_op
Op 40: Thread 8 in DB0 wave_op
Op 41: Thread 9 in DB0 wave_op
Op 42: Thread 10 in DB0 wave_op
Op 43: Thread 11 in DB0 wave_op
Op 44: Thread 12 in DB0 wave_op
Op 45: Thread 13 in DB0 wave_op
Op 46: Thread 14 in DB0 wave_op
Op 47: Thread 15 in DB0 wave_op
Op 48: Thread 16 in DB0 wave_op
Op 49: Thread 17 in DB0 wave_op
Op 50: Thread 18 in DB0 wave_op
Op 51: Thread 19 in DB0 wave_op
Op 52: Thread 20 in DB0 wave_op
Op 53: Thread 21 in DB0 wave_op
Op 54: Thread 22 in DB0 wave_op
Op 55: Thread 23 in DB0 wave_op
Op 56: Thread 24 in DB0 wave_op
Op 57: Thread 25 in DB0 wave_op
Op 58: Thread 26 in DB0 wave_op
Op 59: Thread 27 in DB0 wave_op
Op 60: Thread 28 in DB0 wave_op
Op 61: Thread 29 in DB0 wave_op
Op 62: Thread 30 in DB0 wave_op
Op 63: Thread 31 in DB0 wave_op
Op 64: Thread 0 in DB0 wave_op
Op 65: Thread 1 in DB0 wave_op
Op 66: Thread 2 in DB0 wave_op
Op 67: Thread 3 in DB0 wave_op
Op 68: Thread 4 in DB0 wave_op
Op 69: Thread 5 in DB0 wave_op
Op 70: Thread 6 in DB0 wave_op
Op 71: Thread 7 in DB0 wave_op
Op 72: Thread 8 in DB0 wave_op
Op 73: Thread 9 in DB0 wave_op
Op 74: Thread 10 in DB0 wave_op
Op 75: Thread 11 in DB0 wave_op
Op 76: Thread 12 in DB0 wave_op
Op 77: Thread 13 in DB0 wave_op
Op 78: Thread 14 in DB0 wave_op
Op 79: Thread 15 in DB0 wave_op
Op 80: Thread 16 in DB0 wave_op
Op 81: Thread 17 in DB0 wave_op
Op 82: Thread 18 in DB0 wave_op
Op 83: Thread 19 in DB0 wave_op
Op 84: Thread 20 in DB0 wave_op
Op 85: Thread 21 in DB0 wave_op
Op 86: Thread 22 in DB0 wave_op
Op 87: Thread 23 in DB0 wave_op
Op 88: Thread 24 in DB0 wave_op
Op 89: Thread 25 in DB0 wave_op
Op 90: Thread 26 in DB0 wave_op
Op 91: Thread 27 in DB0 wave_op
Op 92: Thread 28 in DB0 wave_op
Op 93: Thread 29 in DB0 wave_op
Op 94: Thread 30 in DB0 wave_op
Op 95: Thread 31 in DB0 wave_op
Op 96: Thread 0 in DB0 wave_op
Op 97: Thread 1 in DB0 wave_op
Op 98: Thread 2 in DB0 wave_op
Op 99: Thread 3 in DB0 wave_op
Op 100: Thread 4 in DB0 wave_op
Op 101: Thread 5 in DB0 wave_op
Op 102: Thread 6 in DB0 wave_op
Op 103: Thread 7 in DB0 wave_op
Op 104: Thread 8 in DB0 wave_op
Op 105: Thread 9 in DB0 wave_op
Op 106: Thread 10 in DB0 wave_op
Op 107: Thread 11 in DB0 wave_op
Op 108: Thread 12 in DB0 wave_op
Op 109: Thread 13 in DB0 wave_op
Op 110: Thread 14 in DB0 wave_op
Op 111: Thread 15 in DB0 wave_op
Op 112: Thread 16 in DB0 wave_op
Op 113: Thread 17 in DB0 wave_op
Op 114: Thread 18 in DB0 wave_op
Op 115: Thread 19 in DB0 wave_op
Op 116: Thread 20 in DB0 wave_op
Op 117: Thread 21 in DB0 wave_op
Op 118: Thread 22 in DB0 wave_op
Op 119: Thread 23 in DB0 wave_op
Op 120: Thread 24 in DB0 wave_op
Op 121: Thread 25 in DB0 wave_op
Op 122: Thread 26 in DB0 wave_op
Op 123: Thread 27 in DB0 wave_op
Op 124: Thread 28 in DB0 wave_op
Op 125: Thread 29 in DB0 wave_op
Op 126: Thread 30 in DB0 wave_op
Op 127: Thread 31 in DB0 wave_op
Op 128: Thread 0 in DB0 wave_op
Op 129: Thread 1 in DB0 wave_op
Op 130: Thread 2 in DB0 wave_op
Op 131: Thread 3 in DB0 wave_op
Op 132: Thread 4 in DB0 wave_op
Op 133: Thread 5 in DB0 wave_op
Op 134: Thread 6 in DB0 wave_op
Op 135: Thread 7 in DB0 wave_op
Op 136: Thread 8 in DB0 wave_op
Op 137: Thread 9 in DB0 wave_op
Op 138: Thread 10 in DB0 wave_op
Op 139: Thread 11 in DB0 wave_op
Op 140: Thread 12 in DB0 wave_op
Op 141: Thread 13 in DB0 wave_op
Op 142: Thread 14 in DB0 wave_op
Op 143: Thread 15 in DB0 wave_op
Op 144: Thread 16 in DB0 wave_op
Op 145: Thread 17 in DB0 wave_op
Op 146: Thread 18 in DB0 wave_op
Op 147: Thread 19 in DB0 wave_op
Op 148: Thread 20 in DB0 wave_op
Op 149: Thread 21 in DB0 wave_op
Op 150: Thread 22 in DB0 wave_op
Op 151: Thread 23 in DB0 wave_op
Op 152: Thread 24 in DB0 wave_op
Op 153: Thread 25 in DB0 wave_op
Op 154: Thread 26 in DB0 wave_op
Op 155: Thread 27 in DB0 wave_op
Op 156: Thread 28 in DB0 wave_op
Op 157: Thread 29 in DB0 wave_op
Op 158: Thread 30 in DB0 wave_op
Op 159: Thread 31 in DB0 wave_op
Op 160: Thread 0 in DB0 wave_op
Op 161: Thread 1 in DB0 wave_op
Op 162: Thread 2 in DB0 wave_op
Op 163: Thread 3 in DB0 wave_op
Op 164: Thread 4 in DB0 wave_op
Op 165: Thread 5 in DB0 wave_op
Op 166: Thread 6 in DB0 wave_op
Op 167: Thread 7 in DB0 wave_op
Op 168: Thread 8 in DB0 wave_op
Op 169: Thread 9 in DB0 wave_op
Op 170: Thread 10 in DB0 wave_op
Op 171: Thread 11 in DB0 wave_op
Op 172: Thread 12 in DB0 wave_op
Op 173: Thread 13 in DB0 wave_op
Op 174: Thread 14 in DB0 wave_op
Op 175: Thread 15 in DB0 wave_op
Op 176: Thread 16 in DB0 wave_op
Op 177: Thread 17 in DB0 wave_op
Op 178: Thread 18 in DB0 wave_op
Op 179: Thread 19 in DB0 wave_op
Op 180: Thread 20 in DB0 wave_op
Op 181: Thread 21 in DB0 wave_op
Op 182: Thread 22 in DB0 wave_op
Op 183: Thread 23 in DB0 wave_op
Op 184: Thread 24 in DB0 wave_op
Op 185: Thread 25 in DB0 wave_op
Op 186: Thread 26 in DB0 wave_op
Op 187: Thread 27 in DB0 wave_op
Op 188: Thread 28 in DB0 wave_op
Op 189: Thread 29 in DB0 wave_op
Op 190: Thread 30 in DB0 wave_op
Op 191: Thread 31 in DB0 wave_op
Op 192: Thread 0 in DB0 wave_op
Op 193: Thread 1 in DB0 wave_op
Op 194: Thread 2 in DB0 wave_op
Op 195: Thread 3 in DB0 wave_op
Op 196: Thread 4 in DB0 wave_op
Op 197: Thread 5 in DB0 wave_op
Op 198: Thread 6 in DB0 wave_op
Op 199: Thread 7 in DB0 wave_op
Op 200: Thread 8 in DB0 wave_op
Op 201: Thread 9 in DB0 wave_op
Op 202: Thread 10 in DB0 wave_op
Op 203: Thread 11 in DB0 wave_op
Op 204: Thread 12 in DB0 wave_op
Op 205: Thread 13 in DB0 wave_op
Op 206: Thread 14 in DB0 wave_op
Op 207: Thread 15 in DB0 wave_op
Op 208: Thread 16 in DB0 wave_op
Op 209: Thread 17 in DB0 wave_op
Op 210: Thread 18 in DB0 wave_op
Op 211: Thread 19 in DB0 wave_op
Op 212: Thread 20 in DB0 wave_op
Op 213: Thread 21 in DB0 wave_op
Op 214: Thread 22 in DB0 wave_op
Op 215: Thread 23 in DB0 wave_op
Op 216: Thread 24 in DB0 wave_op
Op 217: Thread 25 in DB0 wave_op
Op 218: Thread 26 in DB0 wave_op
Op 219: Thread 27 in DB0 wave_op
Op 220: Thread 28 in DB0 wave_op
Op 221: Thread 29 in DB0 wave_op
Op 222: Thread 30 in DB0 wave_op
Op 223: Thread 31 in DB0 wave_op
SIMPLIFIED VALIDATION: Focusing on control flow determinism
Complex DBEG analysis disabled - moved to interpreter
Direct ParseAST complete
=== HLSL Parse with AST Ownership Complete ===
  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
  Waking up lane 3 from WaitingForResume to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001940 block 3
Collective wave operation result: 0
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 0 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0
Waking up lanes to retrieve wave operation results for wave 0
Executing collective wave operation for wave 0 at instruction 0x506000001a00 block 4
Collective wave operation result: 2
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 0 from WaitingForWave to Ready
  Waking up lane 1 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0
Executing collective wave operation for wave 0 at instruction 0x506000001b20 block 5
Collective wave operation result: 2
All results consumed, releasing sync point for wave 0 at instruction 0x506000001940 block 3
Releasing sync point: 0 participants (phase: 3)
  Sync point removed from active list
All results consumed, releasing sync point for wave 0 at instruction 0x506000001a00 block 4
Releasing sync point: 0 participants (phase: 3)
  Sync point removed from active list
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001be0 block 6
Collective wave operation result: 6
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
  Waking up lane 3 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 3 from WaitingForWave to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001ca0 block 7
Collective wave operation result: 20
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
  Waking up lane 3 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001d60 block 8
Collective wave operation result: 54
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
  Waking up lane 3 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0

=== Dynamic Execution Graph (MiniHLSL Interpreter) ===
Threadgroup Size: 4
Wave Size: 32
Wave Count: 1
Total Dynamic Blocks: 8
Next Block ID: 9

Dynamic Block 1:
  Block ID: 1
  Block Type: REGULAR
  Parent Block: 0
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0

Dynamic Block 2:
  Block ID: 2
  Block Type: SWITCH_HEADER
  Parent Block: 1
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004390
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0

Dynamic Block 3:
  Block ID: 3
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004391
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001940)

Dynamic Block 4:
  Block ID: 4
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004392
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001a00)

Dynamic Block 5:
  Block ID: 5
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004393
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001b20)

Dynamic Block 6:
  Block ID: 6
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004394
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001be0)

Dynamic Block 7:
  Block ID: 7
  Block Type: SWITCH_DEFAULT
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004390
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001ca0)

Dynamic Block 8:
  Block ID: 8
  Block Type: SWITCH_MERGE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004390
  Participating Lanes by Wave:
    Wave 0: {2, 3} (2 lanes)
  Total Participating Lanes: 2
  Arrived Lanes by Wave:
    Wave 0: {2, 3} (2 lanes)
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001d60)

=== Wave States ===
Wave 0:
  Wave Size: 32
  Lane Count: 4
  Active Lanes: 2
  Currently Active Lanes: 2
  Lane to Block Mapping (from registry):
    Lane 2 -> Block 8
    Lane 3 -> Block 8
  Active Sync Points (4):
    Instruction 0x506000001b20 block 5 (WaveActiveOp):
      Expected: 1 lanes
      Arrived: 1 lanes
      Ready to execute: No
    Instruction 0x506000001be0 block 6 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No
    Instruction 0x506000001ca0 block 7 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No
    Instruction 0x506000001d60 block 8 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No

=== End Dynamic Execution Graph ===


=== Final Variable Values ===
Wave 0:
  Lane 0:
    i = 0
    laneId = 0
    result = 2
    (returned: 0)
    (state: Completed)
  Lane 1:
    i = 0
    laneId = 1
    result = 2
    (returned: 0)
    (state: Completed)
  Lane 2:
    i = 0
    laneId = 2
    result = 28
    totalSum = 54
    (state: Completed)
  Lane 3:
    i = 0
    laneId = 3
    result = 26
    totalSum = 54
    (state: Completed)
=== End Variable Values ===

  Waking up lane 0 from WaitingForResume to Ready
  Waking up lane 1 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
  Waking up lane 3 from WaitingForResume to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001940 block 3
Collective wave operation result: 0
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 0 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0
Waking up lanes to retrieve wave operation results for wave 0
Executing collective wave operation for wave 0 at instruction 0x506000001a00 block 4
Collective wave operation result: 2
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 0 from WaitingForWave to Ready
  Waking up lane 1 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0
Executing collective wave operation for wave 0 at instruction 0x506000001b20 block 5
Collective wave operation result: 2
All results consumed, releasing sync point for wave 0 at instruction 0x506000001940 block 3
Releasing sync point: 0 participants (phase: 3)
  Sync point removed from active list
All results consumed, releasing sync point for wave 0 at instruction 0x506000001a00 block 4
Releasing sync point: 0 participants (phase: 3)
  Sync point removed from active list
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001be0 block 6
Collective wave operation result: 6
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
  Waking up lane 3 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 3 from WaitingForWave to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001ca0 block 7
Collective wave operation result: 20
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
  Waking up lane 3 from WaitingForResume to Ready
  Waking up lane 2 from WaitingForResume to Ready
Executing collective wave operation for wave 0 at instruction 0x506000001d60 block 8
Collective wave operation result: 54
Waking up lanes to retrieve wave operation results for wave 0
  Waking up lane 2 from WaitingForWave to Ready
  Waking up lane 3 from WaitingForWave to Ready
Waking up lanes to retrieve wave operation results for wave 0

=== Dynamic Execution Graph (MiniHLSL Interpreter) ===
Threadgroup Size: 4
Wave Size: 32
Wave Count: 1
Total Dynamic Blocks: 8
Next Block ID: 9

Dynamic Block 1:
  Block ID: 1
  Block Type: REGULAR
  Parent Block: 0
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0

Dynamic Block 2:
  Block ID: 2
  Block Type: SWITCH_HEADER
  Parent Block: 1
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004390
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0

Dynamic Block 3:
  Block ID: 3
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004391
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001940)

Dynamic Block 4:
  Block ID: 4
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004392
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001a00)

Dynamic Block 5:
  Block ID: 5
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004393
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001b20)

Dynamic Block 6:
  Block ID: 6
  Block Type: SWITCH_CASE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004394
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001be0)

Dynamic Block 7:
  Block ID: 7
  Block Type: SWITCH_DEFAULT
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004390
  Participating Lanes by Wave:
    Wave 0: {} (0 lanes)
  Total Participating Lanes: 0
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001ca0)

Dynamic Block 8:
  Block ID: 8
  Block Type: SWITCH_MERGE
  Parent Block: 2
  Program Point: 0
  Is Converged: No
  Nesting Level: 0
  Source Statement: 0x504000004390
  Participating Lanes by Wave:
    Wave 0: {2, 3} (2 lanes)
  Total Participating Lanes: 2
  Arrived Lanes by Wave:
    Wave 0: {2, 3} (2 lanes)
  Instructions (1):
    0: WaveActiveOp (ptr: 0x506000001d60)

=== Wave States ===
Wave 0:
  Wave Size: 32
  Lane Count: 4
  Active Lanes: 2
  Currently Active Lanes: 2
  Lane to Block Mapping (from registry):
    Lane 2 -> Block 8
    Lane 3 -> Block 8
  Active Sync Points (4):
    Instruction 0x506000001b20 block 5 (WaveActiveOp):
      Expected: 1 lanes
      Arrived: 1 lanes
      Ready to execute: No
    Instruction 0x506000001be0 block 6 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No
    Instruction 0x506000001ca0 block 7 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No
    Instruction 0x506000001d60 block 8 (WaveActiveOp):
      Expected: 2 lanes
      Arrived: 2 lanes
      Ready to execute: No

=== End Dynamic Execution Graph ===


=== Final Variable Values ===
Wave 0:
  Lane 0:
    i = 0
    laneId = 0
    result = 2
    (returned: 0)
    (state: Completed)
  Lane 1:
    i = 0
    laneId = 1
    result = 2
    (returned: 0)
    (state: Completed)
  Lane 2:
    i = 0
    laneId = 2
    result = 28
    totalSum = 54
    (state: Completed)
  Lane 3:
    i = 0
    laneId = 3
    result = 26
    totalSum = 54
    (state: Completed)
=== End Variable Values ===



=== VERIFICATION ===
✅ totalSum: 54 (found 4 instances)

